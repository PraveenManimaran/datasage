<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visualization - DataSage</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #1f2937;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .header {
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1rem 0;
        }

        .header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4f46e5;
            text-decoration: none;
        }

        .user-menu {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: #4f46e5;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        .guest-badge {
            background: #fef3c7;
            color: #92400e;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .back-btn {
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
        }

        .back-btn:hover {
            background: #4b5563;
        }

        .main {
            padding: 2rem 0;
        }

        .page-header {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .page-title {
            font-size: 2rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 0.5rem;
        }

        .page-subtitle {
            color: #6b7280;
            font-size: 1.125rem;
        }

        .data-info {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1rem;
        }

        .data-info-title {
            font-weight: 600;
            color: #0c4a6e;
            margin-bottom: 0.5rem;
        }

        .data-info-text {
            color: #0369a1;
            font-size: 0.875rem;
        }

        .tabs-container {
            background: white;
            border-radius: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .tabs-header {
            display: flex;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            overflow-x: auto;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.2s ease;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: #f3f4f6;
            color: #4f46e5;
        }

        .tab-button.active {
            background: white;
            color: #4f46e5;
            border-bottom-color: #4f46e5;
        }

        .tab-content {
            display: none;
            padding: 2rem;
        }

        .tab-content.active {
            display: block;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .chart-container {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .chart-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            text-align: center;
        }

        .chart-wrapper {
            position: relative;
            height: 350px;
            margin-bottom: 1rem;
        }

        .chart-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .chart-btn {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
        }

        .chart-btn:hover {
            background: #4338ca;
        }

        .chart-btn.secondary {
            background: #6b7280;
        }

        .chart-btn.secondary:hover {
            background: #4b5563;
        }

        .data-table-container {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .table-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
        }

        .search-container {
            background: white;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            margin-bottom: 1rem;
        }

        .search-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .search-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }

        .search-results {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .search-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .column-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .column-selector label {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
        }

        .column-selector select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            min-width: 150px;
        }

        .column-selector select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .search-input-container {
            position: relative;
            flex: 1;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            color: #374151;
            background: white;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .search-input::placeholder {
            color: #9ca3af;
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            font-size: 1rem;
        }

        .clear-search {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: color 0.2s ease;
        }

        .clear-search:hover {
            color: #6b7280;
        }

        .no-results {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-style: italic;
            font-size: 1rem;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            margin: 1rem 0;
        }

        .row-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .row-selector label {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
        }

        .row-selector select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
        }

        .row-selector select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .table-wrapper {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .table-scroll {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
        }





        .data-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .data-type-row {
            background: #f0f9ff;
            border-bottom: 2px solid #e5e7eb;
        }

        .data-type {
            background: #f0f9ff;
            font-size: 0.75rem;
            color: #0369a1;
            font-weight: 500;
            text-align: center;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            position: sticky;
            top: 40px;
            z-index: 9;
        }

        .data-table tr:hover {
            background: #f9fafb;
        }

        .data-type {
            font-size: 0.75rem;
            font-weight: 500;
            color: #6b7280;
            background-color: #f3f4f6;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
        }

        .data-type.type-override {
            color: #4f46e5;
            background-color: #eff6ff;
            border: 1px solid #bfdbfe;
        }

        .row-count-info {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 1rem;
            text-align: center;
        }

        .stats-controls {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            margin-bottom: 2rem;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stats-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
        }

        .variable-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .variable-selector label {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
        }

        .variable-help {
            margin-top: 0.25rem;
            color: #6b7280;
            font-size: 0.75rem;
        }

        .multi-variable-stats {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .variable-stats-group {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .variable-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 0.5rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .variable-type-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .variable-type-badge.numeric {
            background: #dbeafe;
            color: #1e40af;
        }

        .variable-type-badge.categorical {
            background: #fef3c7;
            color: #92400e;
        }

        .plot-configuration {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .plot-controls {
            margin-bottom: 2rem;
        }

        .plot-type-selector {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .plot-type-selector label {
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            min-width: 120px;
        }

        .plot-type-selector select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            min-width: 200px;
        }

        .axis-configuration {
            border-top: 1px solid #e5e7eb;
            padding-top: 2rem;
        }

        .axis-config-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 1.5rem 0;
        }

        .axis-controls {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .range-controls {
            border-top: 1px solid #e5e7eb;
            padding-top: 2rem;
            margin-top: 2rem;
        }

        .range-controls-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 1.5rem 0;
        }

        .range-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .range-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .range-group label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .range-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .range-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
        }

        .range-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .range-separator {
            color: #6b7280;
            font-weight: 500;
        }

        .range-buttons {
            display: flex;
            gap: 1rem;
            align-items: center;
        }



        .range-btn {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .range-btn:hover {
            background: #4338ca;
        }

        .range-btn.secondary {
            background: #6b7280;
        }

        .range-btn.secondary:hover {
            background: #4b5563;
        }

        .range-info {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .regression-controls {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .regression-controls-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .regression-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .regression-checkbox {
            width: 1.25rem;
            height: 1.25rem;
            accent-color: #4f46e5;
            cursor: pointer;
        }

        .regression-label {
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            font-weight: 500;
        }

        .r-squared-display {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 0.5rem;
            padding: 1rem;
            font-size: 0.875rem;
            color: #1e40af;
            display: none;
        }

        .r-squared-value {
            font-weight: 600;
            font-size: 1rem;
        }

        .equation-display {
            margin-top: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #374151;
        }

        .datatypes-container {
            padding: 2rem;
        }

        .datatypes-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 1rem;
        }

        .datatypes-description {
            color: #6b7280;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .column-type-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .column-type-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            padding: 1.5rem;
            transition: all 0.2s ease;
        }

        .column-type-card:hover {
            border-color: #4f46e5;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .column-type-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .column-name {
            font-weight: 600;
            color: #1f2937;
            font-size: 1rem;
        }

        .current-type-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .type-numeric {
            background: #dbeafe;
            color: #1e40af;
        }

        .type-categorical {
            background: #fef3c7;
            color: #d97706;
        }

        .type-date {
            background: #f0fdf4;
            color: #16a34a;
        }

        .type-boolean {
            background: #fdf4ff;
            color: #a21caf;
        }

        .type-null {
            background: #f3f4f6;
            color: #6b7280;
        }

        .type-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .type-selector {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            min-width: 120px;
        }

        .type-selector:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .apply-type-btn {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .apply-type-btn:hover {
            background: #4338ca;
        }

        .apply-type-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .column-preview {
            margin-top: 1rem;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }

        .preview-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 0.5rem;
        }

        .preview-values {
            font-size: 0.875rem;
            color: #374151;
            font-family: 'Courier New', monospace;
        }

        .apply-all-section {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .apply-all-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
        }

        .apply-all-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .apply-all-btn {
            background: #059669;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .apply-all-btn:hover {
            background: #047857;
        }

        .aggregation-controls {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .aggregation-controls-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .aggregation-selector {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .aggregation-selector label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }

        .aggregation-select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            max-width: 200px;
        }

        .aggregation-select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .aggregation-info {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
            line-height: 1.4;
        }

        .axis-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
        }

        .axis-group label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .axis-group select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
        }

        .plot-preview {
            background: #f9fafb;
            border: 2px dashed #d1d5db;
            border-radius: 0.75rem;
            padding: 3rem 2rem;
            text-align: center;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-placeholder {
            color: #6b7280;
        }

        .preview-placeholder .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-placeholder p {
            font-size: 1rem;
            margin: 0;
        }

        .preview-ready {
            color: #059669;
        }

        .preview-ready .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-ready h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
        }

        .preview-ready p {
            font-size: 0.875rem;
            margin: 0.25rem 0;
        }

        .generate-plot-btn {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 1rem;
            transition: background-color 0.2s;
        }

        .generate-plot-btn:hover {
            background: #4338ca;
        }

        .preview-error {
            color: #dc2626;
        }

        .preview-error .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-error h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
        }

        .preview-error p {
            font-size: 0.875rem;
            margin: 0.25rem 0;
        }

        .preview-cardinality-error {
            color: #d97706;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-cardinality-error .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-cardinality-error h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #92400e;
        }

        .error-message {
            font-size: 0.875rem;
            margin: 0.75rem 0;
            line-height: 1.6;
        }

        .cardinality-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .cardinality-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .axis-help {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 0.375rem;
            color: #92400e;
        }

        .axis-help small {
            font-size: 0.75rem;
            font-weight: 500;
        }

        .preview-axis-type-error {
            color: #dc2626;
            background: #fef2f2;
            border: 1px solid #f87171;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-axis-type-error .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-axis-type-error h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #991b1b;
        }

        .axis-type-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .axis-type-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .preview-low-uniqueness-warning {
            color: #d97706;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-low-uniqueness-warning .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-low-uniqueness-warning h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #92400e;
        }

        .low-uniqueness-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .low-uniqueness-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .aggregation-method-selector {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }

        .aggregation-method-selector label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-right: 0.5rem;
        }

        .aggregation-method-selector select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
        }

        .preview-categorical-aggregation-option {
            color: #059669;
            background: #ecfdf5;
            border: 1px solid #10b981;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-categorical-aggregation-option .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-categorical-aggregation-option h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #047857;
        }

        .categorical-aggregation-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .categorical-aggregation-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .preview-high-cardinality-binning {
            color: #2563eb;
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-high-cardinality-binning .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-high-cardinality-binning h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #1e40af;
        }

        .high-cardinality-binning-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .high-cardinality-binning-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 180px;
        }

        .binning-controls {
            margin-top: 1rem;
            padding: 1.5rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
        }

        .binning-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .binning-control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .binning-control-group label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .binning-control-group select,
        .binning-control-group input {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
        }

        .binning-preview-info {
            background: #dbeafe;
            border: 1px solid #3b82f6;
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1rem 0;
            font-size: 0.875rem;
            color: #1e40af;
        }

        .preview-temporal-suggestion {
            color: #059669;
            background: #ecfdf5;
            border: 1px solid #10b981;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-temporal-suggestion .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-temporal-suggestion h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #047857;
        }

        .temporal-suggestion-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .temporal-suggestion-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .preview-histogram-boolean-warning {
            color: #d97706;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-histogram-boolean-warning .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-histogram-boolean-warning h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #92400e;
        }

        .histogram-boolean-warning-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .histogram-boolean-warning-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .preview-histogram-low-uniqueness-warning {
            color: #d97706;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 0.75rem;
            padding: 2rem;
        }

        .preview-histogram-low-uniqueness-warning .preview-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .preview-histogram-low-uniqueness-warning h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            color: #92400e;
        }

        .histogram-low-uniqueness-warning-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .histogram-low-uniqueness-warning-actions button {
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            min-width: 160px;
        }

        .histogram-controls {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        .histogram-controls-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .histogram-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .histogram-control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .histogram-control-group label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .histogram-control-group select,
        .histogram-control-group input {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
        }

        .plot-container {
            margin-top: 2rem;
            background: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            border: 1px solid #e5e7eb;
            min-height: 600px;
            width: 100%;
        }

        .plot-container canvas {
            max-height: 550px;
            width: 100% !important;
        }

        .plot-controls {
            margin-bottom: 1rem;
            text-align: right;
        }

        .reset-points-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .reset-points-btn:hover {
            background: #b91c1c;
        }



        .variable-selector select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            min-width: 200px;
            max-width: 300px;
        }

        .variable-selector select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .stats-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            accent-color: #4f46e5;
            cursor: pointer;
        }

        .checkbox-group label {
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            user-select: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            text-align: center;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #4f46e5;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: #6b7280;
            font-weight: 500;
        }

        .no-stats {
            text-align: center;
            padding: 3rem;
            color: #6b7280;
        }

        .no-stats-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .categorical-details {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            margin-top: 2rem;
        }

        .categorical-details h4 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
        }

        .category-list {
            display: grid;
            gap: 0.75rem;
        }

        .category-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }

        .category-name {
            font-weight: 500;
            color: #374151;
        }

        .category-count {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
        }

        .missing-data-container {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .missing-data-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
        }

        .missing-data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .missing-data-table th,
        .missing-data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .missing-data-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
        }

        .missing-percentage {
            color: #dc2626;
            font-weight: 600;
        }

        .correlation-container {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .correlation-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
        }

        .correlation-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
        }

        .correlation-control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .correlation-control-group label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .correlation-checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .correlation-checkbox-group input[type="checkbox"] {
            width: 1.125rem;
            height: 1.125rem;
            accent-color: #4f46e5;
            cursor: pointer;
        }

        .correlation-checkbox-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            margin: 0;
        }

        .correlation-column-selector {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem;
            background: white;
        }

        .correlation-column-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem;
            margin-bottom: 0.25rem;
        }

        .correlation-column-item input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            accent-color: #4f46e5;
        }

        .correlation-column-item label {
            font-size: 0.8rem;
            color: #374151;
            cursor: pointer;
            margin: 0;
            flex: 1;
        }

        .correlation-select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
        }

        .correlation-matrix-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        .correlation-table-container {
            flex: 1;
            overflow-x: auto;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .correlation-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            min-width: 400px;
        }

        .correlation-table th,
        .correlation-table td {
            padding: 0.75rem 0.5rem;
            text-align: center;
            border: 1px solid #e5e7eb;
            position: relative;
        }

        .correlation-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
            font-size: 0.8rem;
        }

        .correlation-value {
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .correlation-value:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            border-radius: 0.25rem;
        }

        .correlation-legend {
            width: 120px;
            padding: 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            flex-shrink: 0;
        }

        .correlation-legend-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
            text-align: center;
        }

        .correlation-colorbar {
            width: 100%;
            height: 200px;
            background: linear-gradient(to bottom, 
                #1f77b4 0%,     /* Strong positive */
                #74a9cf 20%,    /* Moderate positive */
                #c6dbef 40%,    /* Weak positive */
                #ffffff 50%,    /* Zero */
                #fcbba1 60%,    /* Weak negative */
                #fc8a6a 80%,    /* Moderate negative */
                #d62728 100%    /* Strong negative */
            );
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            position: relative;
        }

        .correlation-colorbar-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 200px;
            font-size: 0.75rem;
            color: #6b7280;
            margin-left: 0.5rem;
        }

        .correlation-legend-ranges {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.5rem;
        }

        .correlation-legend-ranges div {
            margin-bottom: 0.25rem;
        }

        .correlation-tooltip {
            position: absolute;
            background: #1f2937;
            color: white;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            max-width: 250px;
        }

        .correlation-tooltip.visible {
            opacity: 1;
        }

        .correlation-grayscale .correlation-table {
            filter: grayscale(100%);
        }

        .correlation-stats {
            margin-top: 1rem;
            padding: 1rem;
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            color: #0c4a6e;
        }

        .correlation-export-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .correlation-export-btn {
            padding: 0.5rem 0.75rem;
            background: #4f46e5;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .correlation-export-btn:hover {
            background: #4338ca;
        }

        .correlation-export-btn:active {
            background: #3730a3;
        }

        .correlation-export-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .export-progress {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #4f46e5;
            margin-top: 0.5rem;
        }

        .export-spinner {
            width: 1rem;
            height: 1rem;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-data {
            text-align: center;
            padding: 3rem;
            color: #6b7280;
        }

        .no-data-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }
            
            .visualization-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-wrapper {
                height: 300px;
            }
            
            .data-table {
                font-size: 0.75rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <a href="dashboard.html" class="logo">DataSage</a>
            <div class="user-menu">
                <div class="user-avatar">G</div>
                <span class="guest-badge">Demo Mode</span>
                <button class="back-btn" onclick="goBack()">Back to Dashboard</button>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="page-header">
                <h1 class="page-title">Data Visualization</h1>
                <p class="page-subtitle">Explore your data through interactive charts and insights</p>
                <div class="data-info" id="dataInfo">
                    <div class="data-info-title">Dataset: <span id="fileName">sample_data.csv</span></div>
                    <div class="data-info-text">Rows: <span id="rowCount">0</span> | Columns: <span id="colCount">0</span></div>
                </div>
            </div>

            <div class="tabs-container">
                <div class="tabs-header">
                    <button class="tab-button active" onclick="showTab('preview')">Preview Data</button>
                    <button class="tab-button" onclick="showTab('datatypes')">Data Types</button>
                    <button class="tab-button" onclick="showTab('summary')">Summary Statistics</button>
                    <button class="tab-button" onclick="showTab('missing')">Missing Data</button>
                    <button class="tab-button" onclick="showTab('plots')">Plots</button>
                    <button class="tab-button" onclick="showTab('correlation')">Correlation</button>
                </div>

                <div id="preview" class="tab-content active">
                    <!-- Preview Data content -->
                </div>

                <div id="datatypes" class="tab-content">
                    <!-- Data Types content -->
                </div>

                <div id="summary" class="tab-content">
                    <!-- Summary Statistics content -->
                </div>

                <div id="missing" class="tab-content">
                    <!-- Missing Data content -->
                </div>

                <div id="plots" class="tab-content">
                    <!-- Plots content -->
                </div>

                <div id="correlation" class="tab-content">
                    <!-- Correlation content -->
                </div>
            </div>
        </div>
    </main>

    <script>
        let csvData = [];
        let headers = [];
        let charts = {};

        // Check if user is in demo mode
        document.addEventListener('DOMContentLoaded', () => {
            if (!localStorage.getItem('isGuest')) {
                localStorage.setItem('isGuest', 'true');
            }
            
            // Load CSV data from localStorage
            loadCSVData();
        });

        function loadCSVData() {
            const csvContent = localStorage.getItem('csvData');
            const fileName = localStorage.getItem('uploadedFile') || 'sample_data.csv';
            
            if (!csvContent) {
                showNoData();
                return;
            }

            // Parse CSV data
            parseCSV(csvContent);
            
            // Load saved column type overrides
            loadColumnTypeOverrides();
            
            // Update file info
            document.getElementById('fileName').textContent = fileName;
            document.getElementById('rowCount').textContent = csvData.length;
            document.getElementById('colCount').textContent = headers.length;
            
            // Generate visualizations
            generateVisualizations();
        }

        function parseCSV(csvContent) {
            const lines = csvContent.split('\n');
            const rawHeaders = parseCSVLine(lines[0]).map(h => h.trim().replace(/"/g, ''));
            
            // Keep all columns including index column, but give empty header a name
            headers = rawHeaders.map((h, index) => h.trim() === '' ? `Column ${index + 1}` : h.trim()).filter(h => h !== '');
            
            csvData = [];
            for (let i = 1; i < lines.length; i++) {
                // Skip empty lines
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]).map(v => v.trim().replace(/"/g, ''));
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                csvData.push(row);
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Handle escaped quotes (double quotes)
                        current += '"';
                        i += 2;
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                        i++;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    result.push(current);
                    current = '';
                    i++;
                } else {
                    // Regular character
                    current += char;
                    i++;
                }
            }
            
            // Add the last field
            result.push(current);
            
            return result;
        }

        function generateVisualizations() {
            // Generate content for each tab
            generatePreviewTab();
            generateSummaryTab();
            generateMissingDataTab();
            generateDataTypesTab();
            generatePlotsTab();
            generateCorrelationTab();
            
            // Initialize charts after DOM is ready
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }

        function generateStats() {
            const allColumns = headers.filter(header => !shouldIgnoreColumn(getEffectiveVariableType(header)));
            const numericColumns = headers.filter(header => {
                return isNumericType(getEffectiveVariableType(header));
            });
            const categoricalColumns = headers.filter(header => {
                const type = getEffectiveVariableType(header);
                return (isCategoricalType(type) || isDateType(type)) && !shouldIgnoreColumn(type);
            });

            if (allColumns.length === 0) {
                return `
                    <div class="no-stats">
                        <div class="no-stats-icon">📊</div>
                        <h3>No Data</h3>
                        <p>No columns found for statistical analysis.</p>
                    </div>
                `;
            }

            // Default to first column selected
            const defaultSelectedVariables = [allColumns[0]];

            return `
                <div class="stats-controls">
                    <div class="stats-header">
                        <h3 class="stats-title">Summary Statistics</h3>
                        <div class="variable-selector">
                            <label for="variableSelect">Select Variables:</label>
                            <select id="variableSelect" multiple onchange="updateSummaryStats()" size="6">
                                <optgroup label="Numeric Variables">
                                    ${numericColumns.map(col => `
                                        <option value="${col}" ${defaultSelectedVariables.includes(col) ? 'selected' : ''}>${col}</option>
                                    `).join('')}
                                </optgroup>
                                <optgroup label="Categorical Variables">
                                    ${categoricalColumns.map(col => `
                                        <option value="${col}" ${defaultSelectedVariables.includes(col) ? 'selected' : ''}>${col}</option>
                                    `).join('')}
                                </optgroup>
                            </select>
                            <div class="variable-help">
                                <small>Hold Ctrl/Cmd to select multiple variables</small>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="statsResults">
                    ${generateMultiVariableStatsResults(defaultSelectedVariables)}
                </div>
            `;
        }

        function generateCharts() {
            const numericColumns = headers.filter(header => {
                return csvData.some(row => !isNaN(row[header]) && row[header] !== '');
            });

            if (numericColumns.length === 0) {
                return '<div class="no-data"><div class="no-data-icon">📊</div><p>No numeric data found for visualization</p></div>';
            }

            const chartTypes = [
                { type: 'bar', title: 'Bar Chart', data: numericColumns[0] },
                { type: 'line', title: 'Line Chart', data: numericColumns[0] },
                { type: 'pie', title: 'Distribution', data: numericColumns[0] },
                { type: 'scatter', title: 'Scatter Plot', data: numericColumns.length > 1 ? numericColumns.slice(0, 2) : [numericColumns[0], numericColumns[0]] }
            ];

            return `
                <div class="visualization-grid">
                    ${chartTypes.map((chart, index) => `
                        <div class="chart-container">
                            <h3 class="chart-title">${chart.title}</h3>
                            <div class="chart-wrapper">
                                <canvas id="chart${index}"></canvas>
                            </div>
                            <div class="chart-actions">
                                <button class="chart-btn" onclick="downloadChart(${index})">Download</button>
                                <button class="chart-btn secondary" onclick="refreshChart(${index})">Refresh</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function generateDataTable(rowsToShow = 25, searchTerm = '', selectedColumn = 'all') {
            const totalRows = csvData.length;
            
            // Filter data based on search term and selected column
            let filteredData = csvData;
            if (searchTerm.trim() !== '') {
                const searchLower = searchTerm.toLowerCase();
                filteredData = csvData.filter(row => {
                    if (selectedColumn === 'all') {
                        return headers.some(header => {
                            const value = row[header] || '';
                            return value.toString().toLowerCase().includes(searchLower);
                        });
                    } else {
                        const value = row[selectedColumn] || '';
                        return value.toString().toLowerCase().includes(searchLower);
                    }
                });
            }
            
            const displayRows = rowsToShow === 'all' ? filteredData.length : Math.min(rowsToShow, filteredData.length);
            
            // Get effective data types for each column (includes user overrides)
            const dataTypes = headers.map(header => {
                const type = getEffectiveVariableType(header);
                const displayName = getTypeDisplayName(type);
                const isOverridden = columnTypeOverrides[header] !== undefined;
                return {
                    display: displayName,
                    isOverridden: isOverridden
                };
            });
            
                            return `
                <div class="data-table-container">
                    <div class="search-container">
                        <div class="search-header">
                            <span class="search-label">Search:</span>
                            <span class="search-results" id="searchResults">
                                ${searchTerm.trim() !== '' ? `Found ${filteredData.length} matching rows` : ''}
                            </span>
                        </div>
                        <div class="search-controls">
                            <div class="column-selector">
                                <label for="columnSelect">Column:</label>
                                <select id="columnSelect" onchange="handleColumnChange(this.value)">
                                    <option value="all" ${selectedColumn === 'all' ? 'selected' : ''}>All Columns</option>
                                    ${headers.map(header => `
                                        <option value="${header}" ${selectedColumn === header ? 'selected' : ''}>${header}</option>
                                    `).join('')}
                                </select>
                            </div>
                            <div class="search-input-container">
                                <span class="search-icon">🔍</span>
                                <input 
                                    type="text" 
                                    class="search-input" 
                                    id="searchInput" 
                                    placeholder="${selectedColumn === 'all' ? 'Type to search across all columns...' : `Type to search in ${selectedColumn}...`}"
                                    value="${searchTerm}"
                                    oninput="handleSearch(this.value)"
                                >
                                ${searchTerm.trim() !== '' ? `
                                    <button class="clear-search" onclick="clearSearch()" title="Clear search">✕</button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="table-header">
                        <h3 class="table-title">Data Preview</h3>
                        <div class="row-selector">
                            <label for="rowSelector">Show rows:</label>
                            <select id="rowSelector" onchange="updateTableRows(this.value)">
                                <option value="10" ${rowsToShow === 10 ? 'selected' : ''}>10</option>
                                <option value="25" ${rowsToShow === 25 ? 'selected' : ''}>25</option>
                                <option value="50" ${rowsToShow === 50 ? 'selected' : ''}>50</option>
                                <option value="100" ${rowsToShow === 100 ? 'selected' : ''}>100</option>
                                <option value="500" ${rowsToShow === 500 ? 'selected' : ''}>500</option>
                                <option value="1000" ${rowsToShow === 1000 ? 'selected' : ''}>1000</option>
                                <option value="all" ${rowsToShow === 'all' ? 'selected' : ''}>All Rows</option>
                            </select>
                        </div>
                    </div>
                    <div class="table-wrapper">
                        <div class="table-scroll">
                            <table class="data-table" id="dataTable">
                                <thead>
                                    <tr>
                                        ${headers.map(header => `<th>${header}</th>`).join('')}
                                    </tr>
                                    <tr class="data-type-row">
                                        ${dataTypes.map(typeInfo => `<td class="data-type ${typeInfo.isOverridden ? 'type-override' : ''}">Type: ${typeInfo.display}</td>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${filteredData && filteredData.length > 0 ? filteredData.slice(0, displayRows).map((row, index) => `
                                        <tr>
                                            ${headers.map(header => {
                                                const value = row[header] || '';
                                                const shouldHighlight = searchTerm.trim() !== '' && 
                                                    (selectedColumn === 'all' || selectedColumn === header);
                                                const highlightedValue = shouldHighlight ? 
                                                    highlightSearchTerm(value.toString(), searchTerm) : value;
                                                
                                                return `<td>${highlightedValue}</td>`;
                                            }).join('')}
                                        </tr>
                                    `).join('') : `
                                        <tr>
                                            <td colspan="${headers.length}" class="no-results">
                                                ${!csvData || csvData.length === 0 ? 'No data available. Please upload a CSV file.' : 'No rows match your search criteria'}
                                            </td>
                                        </tr>
                                    `}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="row-count-info">
                        ${searchTerm.trim() !== '' ? 
                            `Showing ${displayRows} of ${filteredData.length} filtered rows (from ${totalRows} total)` :
                            `Showing ${displayRows} of ${totalRows} rows`
                        }
                        ${displayRows < filteredData.length ? '(scroll to see more)' : ''}
                    </div>
                </div>
            `;
        }

        function initializeCharts() {
            const numericColumns = headers.filter(header => {
                return csvData.some(row => !isNaN(row[header]) && row[header] !== '');
            });

            if (numericColumns.length === 0) return;

            // Bar Chart
            createBarChart(0, numericColumns[0]);
            
            // Line Chart
            createLineChart(1, numericColumns[0]);
            
            // Pie Chart
            createPieChart(2, numericColumns[0]);
            
            // Scatter Plot
            if (numericColumns.length > 1) {
                createScatterChart(3, numericColumns[0], numericColumns[1]);
            } else {
                createScatterChart(3, numericColumns[0], numericColumns[0]);
            }
        }

        function createBarChart(index, column) {
            const ctx = document.getElementById(`chart${index}`);
            if (!ctx) return;

            const values = csvData.map(row => parseFloat(row[column])).filter(v => !isNaN(v));
            const labels = Array.from({length: values.length}, (_, i) => `Row ${i + 1}`);

            charts[`chart${index}`] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels.slice(0, 20), // Limit to first 20 for readability
                    datasets: [{
                        label: column,
                        data: values.slice(0, 20),
                        backgroundColor: 'rgba(79, 70, 229, 0.8)',
                        borderColor: 'rgba(79, 70, 229, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function createLineChart(index, column) {
            const ctx = document.getElementById(`chart${index}`);
            if (!ctx) return;

            const values = csvData.map(row => parseFloat(row[column])).filter(v => !isNaN(v));
            const labels = Array.from({length: values.length}, (_, i) => `Row ${i + 1}`);

            charts[`chart${index}`] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels.slice(0, 20),
                    datasets: [{
                        label: column,
                        data: values.slice(0, 20),
                        borderColor: 'rgba(124, 58, 237, 1)',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointBackgroundColor: 'rgba(124, 58, 237, 1)',
                        pointBorderColor: 'rgba(124, 58, 237, 1)',
                        pointBorderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function createPieChart(index, column) {
            const ctx = document.getElementById(`chart${index}`);
            if (!ctx) return;

            const values = csvData.map(row => parseFloat(row[column])).filter(v => !isNaN(v));
            const uniqueValues = [...new Set(values)];
            const counts = uniqueValues.map(val => values.filter(v => v === val).length);

            charts[`chart${index}`] = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: uniqueValues.map(v => v.toString()),
                    datasets: [{
                        data: counts,
                        backgroundColor: [
                            'rgba(79, 70, 229, 0.8)',
                            'rgba(124, 58, 237, 0.8)',
                            'rgba(168, 85, 247, 0.8)',
                            'rgba(217, 70, 239, 0.8)',
                            'rgba(236, 72, 153, 0.8)'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }

        function createScatterChart(index, column1, column2) {
            const ctx = document.getElementById(`chart${index}`);
            if (!ctx) return;

            const data = csvData.map(row => ({
                x: parseFloat(row[column1]),
                y: parseFloat(row[column2])
            })).filter(point => !isNaN(point.x) && !isNaN(point.y));

            charts[`chart${index}`] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `${column1} vs ${column2}`,
                        data: data,
                        backgroundColor: 'rgba(79, 70, 229, 0.6)',
                        borderColor: 'rgba(79, 70, 229, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: column1
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: column2
                            }
                        }
                    }
                }
            });
        }

        function downloadChart(index) {
            const chart = charts[`chart${index}`];
            if (chart) {
                const link = document.createElement('a');
                link.download = `chart${index}.png`;
                link.href = chart.toBase64Image();
                link.click();
            }
        }

        function refreshChart(index) {
            const chart = charts[`chart${index}`];
            if (chart) {
                chart.destroy();
            }
            
            const numericColumns = headers.filter(header => {
                return csvData.some(row => !isNaN(row[header]) && row[header] !== '');
            });

            if (numericColumns.length === 0) return;

            const chartTypes = ['bar', 'line', 'pie', 'scatter'];
            const chartType = chartTypes[index];
            
            if (chartType === 'bar') {
                createBarChart(index, numericColumns[0]);
            } else if (chartType === 'line') {
                createLineChart(index, numericColumns[0]);
            } else if (chartType === 'pie') {
                createPieChart(index, numericColumns[0]);
            } else if (chartType === 'scatter') {
                if (numericColumns.length > 1) {
                    createScatterChart(index, numericColumns[0], numericColumns[1]);
                } else {
                    createScatterChart(index, numericColumns[0], numericColumns[0]);
                }
            }
        }

        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
        }

        function generatePreviewTab() {
            const previewTab = document.getElementById('preview');
            previewTab.innerHTML = generateDataTable(25); // Default to 25 rows
        }

        function generateSummaryTab() {
            const summaryTab = document.getElementById('summary');
            summaryTab.innerHTML = generateStats();
        }

        function generateDataTypesTab() {
            const dataTypesTab = document.getElementById('datatypes');
            dataTypesTab.innerHTML = generateDataTypesContent();
        }

        function generateMissingDataTab() {
            const missingTab = document.getElementById('missing');
            const missingData = analyzeMissingData();
            
            if (missingData.length === 0) {
                missingTab.innerHTML = `
                    <div class="missing-data-container">
                        <h3 class="missing-data-title">Missing Data Analysis</h3>
                        <p>✅ No missing data found in your dataset!</p>
                    </div>
                `;
            } else {
                missingTab.innerHTML = `
                    <div class="missing-data-container">
                        <h3 class="missing-data-title">Missing Data Analysis</h3>
                        <table class="missing-data-table">
                            <thead>
                                <tr>
                                    <th>Column</th>
                                    <th>Missing Values</th>
                                    <th>Percentage</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${missingData.map(item => `
                                    <tr>
                                        <td>${item.column}</td>
                                        <td>${item.missing}</td>
                                        <td class="missing-percentage">${item.percentage}%</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }
        }

        function generatePlotsTab() {
            const plotsTab = document.getElementById('plots');
            const numericColumns = headers.filter(header => {
                return csvData.some(row => !isNaN(row[header]) && row[header] !== '');
            });
            const categoricalColumns = headers.filter(header => {
                return !numericColumns.includes(header);
            });

            // Pre-calculate unique counts for all columns
            const columnUniqueCount = {};
            headers.forEach(header => {
                columnUniqueCount[header] = getUniqueValueCount(header);
            });

            if (numericColumns.length === 0 && categoricalColumns.length === 0) {
                plotsTab.innerHTML = `
                    <div class="no-data">
                        <div class="no-data-icon">📊</div>
                        <p>No data found for visualization</p>
                    </div>
                `;
                return;
            }

            plotsTab.innerHTML = `
                <div class="plot-configuration">
                    <div class="plot-controls">
                        <div class="plot-type-selector">
                            <label for="plotTypeSelect">Select Plot Type:</label>
                            <select id="plotTypeSelect" onchange="updatePlotConfiguration()">
                                <option value="">Choose a plot type...</option>
                                <option value="bar">Bar Chart</option>
                                <option value="line">Line Chart</option>
                                <option value="scatter">Scatter Plot</option>
                                <option value="histogram">Histogram</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="axisConfiguration" class="axis-configuration" style="display: none;">
                        <h3 class="axis-config-title">Axis Configuration</h3>
                        <div class="axis-controls">
                            <div class="axis-group">
                                <label for="xAxisSelect">X-Axis:</label>
                                <select id="xAxisSelect" onchange="updateAxisPreview()">
                                    <option value="">Select X-axis variable...</option>
                                    ${categoricalColumns.map(col => {
                                        const uniqueCount = columnUniqueCount[col] || 0;
                                        const cardinalityWarning = uniqueCount > 50 ? ' ⚠️' : '';
                                        return `<option value="${col}">${col} (${uniqueCount} unique)${cardinalityWarning}</option>`;
                                    }).join('')}
                                    ${numericColumns.map(col => {
                                        const uniqueCount = columnUniqueCount[col] || 0;
                                        const cardinalityWarning = uniqueCount > 50 ? ' ⚠️' : '';
                                        return `<option value="${col}">${col} (${uniqueCount} unique)${cardinalityWarning}</option>`;
                                    }).join('')}
                                </select>
                                <div class="axis-help" id="xAxisHelp" style="display: none;">
                                    <small>⚠️ High cardinality detected. Bar charts work best with &lt;50 categories.</small>
                                </div>
                            </div>
                            <div class="axis-group">
                                <label for="yAxisSelect">Y-Axis:</label>
                                <select id="yAxisSelect" onchange="updateAxisPreview()">
                                    <option value="">Select Y-axis variable...</option>
                                    <option value="count">📊 Count (Number of Records)</option>
                                    ${numericColumns.map(col => `
                                        <option value="${col}">${col}</option>
                                    `).join('')}
                                </select>
                            </div>
                        </div>
                        
                        <div id="rangeControls" class="range-controls" style="display: none;">
                            <h4 class="range-controls-title">Axis Range Controls</h4>
                            <div class="range-controls-grid">
                                <div class="range-group">
                                    <label>X-Axis Range:</label>
                                    <div class="range-inputs">
                                        <input type="number" id="xAxisMin" class="range-input" placeholder="Min" step="any">
                                        <span class="range-separator">to</span>
                                        <input type="number" id="xAxisMax" class="range-input" placeholder="Max" step="any">
                                    </div>
                                    <div class="range-info" id="xAxisRangeInfo">Current range will be shown here</div>
                                </div>
                                <div class="range-group">
                                    <label>Y-Axis Range:</label>
                                    <div class="range-inputs">
                                        <input type="number" id="yAxisMin" class="range-input" placeholder="Min" step="any">
                                        <span class="range-separator">to</span>
                                        <input type="number" id="yAxisMax" class="range-input" placeholder="Max" step="any">
                                    </div>
                                    <div class="range-info" id="yAxisRangeInfo">Current range will be shown here</div>
                                </div>
                            </div>
                            <div class="range-buttons">
                                <button class="range-btn" onclick="applyAxisRanges()">Apply Ranges</button>
                                <button class="range-btn secondary" onclick="resetAxisRanges()">Reset to Auto</button>
                                <button class="range-btn secondary" onclick="setDataRange()">Set to Data Range</button>
                            </div>
                        </div>
                        
                        <div id="regressionControls" class="regression-controls" style="display: none;">
                            <h4 class="regression-controls-title">Regression Analysis</h4>
                            <div class="regression-toggle">
                                <input type="checkbox" id="regressionToggle" class="regression-checkbox" onchange="toggleRegressionLine()">
                                <label for="regressionToggle" class="regression-label">Show line of best fit</label>
                            </div>
                            <div id="rSquaredDisplay" class="r-squared-display">
                                <div>R² = <span id="rSquaredValue" class="r-squared-value">0.000</span></div>
                                <div id="equationDisplay" class="equation-display">y = mx + b</div>
                            </div>
                        </div>
                        
                        <div id="aggregationControls" class="aggregation-controls" style="display: none;">
                            <h4 class="aggregation-controls-title">📊 Data Aggregation Options</h4>
                            <div class="aggregation-selector">
                                <label for="aggregationMethod">How should multiple values be combined?</label>
                                <select id="aggregationMethod" class="aggregation-select" onchange="updateBarChartAggregation()">
                                    <option value="mean">Mean (Average) - Most Common</option>
                                    <option value="median">Median (Middle Value)</option>
                                    <option value="sum">Sum (Total) - Good for Boolean counts</option>
                                    <option value="count">Count (Number of Records)</option>
                                    <option value="min">Minimum Value</option>
                                    <option value="max">Maximum Value</option>
                                </select>
                                <div class="aggregation-info" id="aggregationExplanation">
                                    <strong>📋 Explanation:</strong> When you have multiple data points for each category (e.g., multiple passengers in each class), this setting determines how those values are combined into a single bar height.
                                </div>
                            </div>
                        </div>
                        
                        <div id="histogramControls" class="histogram-controls" style="display: none;">
                            <h4 class="histogram-controls-title">📊 Histogram Configuration</h4>
                            <div class="histogram-controls-grid">
                                <div class="histogram-control-group">
                                    <label for="histogramBinCount">Number of Bins:</label>
                                    <select id="histogramBinCount" onchange="updateHistogram()">
                                        <option value="5">5 bins</option>
                                        <option value="10" selected>10 bins (default)</option>
                                        <option value="20">20 bins</option>
                                        <option value="custom">Custom...</option>
                                    </select>
                                    <input type="number" id="customBinCount" style="display: none; margin-top: 0.5rem;" 
                                           placeholder="Enter bin count" min="2" max="100" onchange="updateHistogram()" oninput="updateHistogram()"
                                           onfocus="window.userIsTyping = true" onblur="window.userIsTyping = false">
                                </div>
                                <div class="histogram-control-group">
                                    <label for="histogramNormalization">Display Type:</label>
                                    <select id="histogramNormalization" onchange="updateHistogram()">
                                        <option value="count">Raw Count</option>
                                        <option value="percent">Percentage</option>
                                    </select>
                                </div>
                            </div>
                            <div class="aggregation-info">
                                <strong>📋 About Histograms:</strong> Y-axis is always count (number of rows in each bin). 
                                Missing values are automatically excluded from the chart.
                            </div>
                        </div>
                        
                        <div class="plot-preview">
                            <div class="preview-placeholder">
                                <div class="preview-icon">📊</div>
                                <p>Configure your plot settings above to see a preview</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateCorrelationTab() {
            const correlationTab = document.getElementById('correlation');
            const numericColumns = headers.filter(header => {
                return isNumericType(getEffectiveVariableType(header)) && !shouldIgnoreColumn(getEffectiveVariableType(header));
            });
            
            if (numericColumns.length < 2) {
                correlationTab.innerHTML = `
                    <div class="correlation-container">
                        <h3 class="correlation-title">Correlation Analysis</h3>
                        <p>At least 2 numeric columns are required for correlation analysis. Found ${numericColumns.length} numeric column(s).</p>
                    </div>
                `;
                return;
            }

            // Initialize correlation settings if not set
            if (!window.correlationSettings) {
                window.correlationSettings = {
                    excludeNulls: false,
                    selectedColumns: [...numericColumns],
                    sortBy: 'none',
                    grayscaleMode: false
                };
            }

            correlationTab.innerHTML = `
                <div class="correlation-container">
                    <h3 class="correlation-title">📈 Enhanced Correlation Matrix</h3>
                    
                    <div class="correlation-controls">
                        <div class="correlation-control-group">
                            <label>📊 Options</label>
                            <div class="correlation-checkbox-group">
                                <input type="checkbox" id="excludeNulls" ${window.correlationSettings.excludeNulls ? 'checked' : ''} 
                                       onchange="updateCorrelationSettings()" 
                                       title="Drop rows with missing values before computing pairwise correlation">
                                <label for="excludeNulls">Exclude rows with missing values</label>
                            </div>
                            <div class="correlation-checkbox-group">
                                <input type="checkbox" id="grayscaleMode" ${window.correlationSettings.grayscaleMode ? 'checked' : ''} 
                                       onchange="updateCorrelationSettings()">
                                <label for="grayscaleMode">Grayscale mode (colorblind-friendly)</label>
                            </div>
                        </div>
                        
                        <div class="correlation-control-group">
                            <label>💾 Export Matrix</label>
                            <div class="correlation-export-controls">
                                <button class="correlation-export-btn" onclick="exportCorrelationCSV()" title="Export correlation matrix as CSV file">
                                    📄 Export CSV
                                </button>
                                <button class="correlation-export-btn" onclick="exportCorrelationPNG()" title="Export visual matrix as PNG image">
                                    🖼️ Export PNG
                                </button>
                            </div>
                        </div>
                        
                        <div class="correlation-control-group">
                            <label for="sortBy">📋 Sort Matrix</label>
                            <select id="sortBy" class="correlation-select" onchange="updateCorrelationSettings()">
                                <option value="none" ${window.correlationSettings.sortBy === 'none' ? 'selected' : ''}>Original order</option>
                                <option value="strongest" ${window.correlationSettings.sortBy === 'strongest' ? 'selected' : ''}>Strongest correlations first</option>
                                <option value="alphabetical" ${window.correlationSettings.sortBy === 'alphabetical' ? 'selected' : ''}>Alphabetical</option>
                            </select>
                        </div>
                        
                        <div class="correlation-control-group">
                            <label>🎯 Select Columns (${window.correlationSettings.selectedColumns.length}/${numericColumns.length})</label>
                            <div class="correlation-column-selector">
                                ${numericColumns.map(col => `
                                    <div class="correlation-column-item">
                                        <input type="checkbox" id="col_${col}" 
                                               ${window.correlationSettings.selectedColumns.includes(col) ? 'checked' : ''}
                                               onchange="updateCorrelationSettings()">
                                        <label for="col_${col}" title="${col}">${col}</label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div id="correlationContent">
                        <!-- Correlation matrix will be rendered here -->
                    </div>
                    
                    <div class="correlation-tooltip" id="correlationTooltip"></div>
                </div>
            `;
            
            renderCorrelationMatrix();
        }

        function updateCorrelationSettings() {
            // Update settings from UI
            const excludeNulls = document.getElementById('excludeNulls')?.checked || false;
            const grayscaleMode = document.getElementById('grayscaleMode')?.checked || false;
            const sortBy = document.getElementById('sortBy')?.value || 'none';
            
            // Get selected columns
            const numericColumns = headers.filter(header => {
                return isNumericType(getEffectiveVariableType(header)) && !shouldIgnoreColumn(getEffectiveVariableType(header));
            });
            
            const selectedColumns = numericColumns.filter(col => {
                const checkbox = document.getElementById(`col_${col}`);
                return checkbox && checkbox.checked;
            });
            
            // Ensure at least 2 columns are selected
            if (selectedColumns.length < 2) {
                alert('Please select at least 2 columns for correlation analysis.');
                return;
            }
            
            window.correlationSettings = {
                excludeNulls,
                selectedColumns,
                sortBy,
                grayscaleMode
            };
            
            renderCorrelationMatrix();
        }

        function renderCorrelationMatrix() {
            const correlationContent = document.getElementById('correlationContent');
            if (!correlationContent) return;
            
            const correlationData = calculateCorrelationsEnhanced();
            
            if (correlationData.matrix.length === 0) {
                correlationContent.innerHTML = `
                    <div style="text-align: center; color: #6b7280; padding: 2rem;">
                        <p>⚠️ Unable to calculate correlations with current settings.</p>
                        <p>Try selecting more columns or changing the null handling option.</p>
                    </div>
                `;
                return;
            }
            
            const containerClass = window.correlationSettings.grayscaleMode ? 'correlation-grayscale' : '';
            
            correlationContent.innerHTML = `
                <div class="${containerClass}">
                    <div class="correlation-matrix-wrapper">
                        <div class="correlation-table-container">
                            <table class="correlation-table">
                                <thead>
                                    <tr>
                                        <th></th>
                                        ${correlationData.columns.map(col => `<th title="${col}">${col}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${correlationData.matrix.map((row, i) => `
                                        <tr>
                                            <th title="${correlationData.columns[i]}">${correlationData.columns[i]}</th>
                                            ${row.map((corr, j) => {
                                                const color = getCorrelationColor(corr);
                                                const textColor = getCorrelationTextColor(corr);
                                                return `<td class="correlation-value" 
                                                           style="background-color: ${color}; color: ${textColor};"
                                                           data-col1="${correlationData.columns[i]}"
                                                           data-col2="${correlationData.columns[j]}"
                                                           data-corr="${corr.toFixed(4)}"
                                                           data-sample-size="${correlationData.sampleSize}"
                                                           onmouseenter="showCorrelationTooltip(event)"
                                                           onmouseleave="hideCorrelationTooltip()"
                                                           onmousemove="moveCorrelationTooltip(event)">
                                                    ${corr.toFixed(3)}
                                                </td>`;
                                            }).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="correlation-legend">
                            <div class="correlation-legend-title">Correlation Scale</div>
                            <div class="correlation-colorbar"></div>
                            <div class="correlation-colorbar-labels">
                                <span>+1.0</span>
                                <span>+0.5</span>
                                <span>0.0</span>
                                <span>-0.5</span>
                                <span>-1.0</span>
                            </div>
                            <div class="correlation-legend-ranges">
                                <div><strong>Strength:</strong></div>
                                <div>|r| > 0.5: Strong</div>
                                <div>0.3-0.5: Moderate</div>
                                <div>0.1-0.3: Weak</div>
                                <div>< 0.1: Negligible</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="correlation-stats">
                        <strong>📊 Analysis Summary:</strong><br>
                        • Sample size: ${correlationData.sampleSize} rows<br>
                        • Matrix size: ${correlationData.columns.length}×${correlationData.columns.length}<br>
                        • Missing values: ${window.correlationSettings.excludeNulls ? 'Excluded' : 'Handled pairwise'}<br>
                        • Strongest correlation: ${correlationData.strongestCorr ? `${correlationData.strongestCorr.value.toFixed(3)} (${correlationData.strongestCorr.col1} ↔ ${correlationData.strongestCorr.col2})` : 'N/A'}
                    </div>
                </div>
            `;
        }

        function updatePlotConfiguration() {
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            const axisConfiguration = document.getElementById('axisConfiguration');
            
            if (!plotTypeSelect || !axisConfiguration) return;
            
            const selectedPlotType = plotTypeSelect.value;
            
            if (selectedPlotType) {
                axisConfiguration.style.display = 'block';
                updateAxisPreview();
            } else {
                axisConfiguration.style.display = 'none';
            }
        }

        function updateAxisPreview() {
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');
            
            if (!plotTypeSelect || !xAxisSelect || !yAxisSelect) return;
            
            const selectedPlotType = plotTypeSelect.value;
            const selectedXAxis = xAxisSelect.value;
            const selectedYAxis = yAxisSelect.value;
            
            // Clear any previous warning overrides when configuration changes
            window.ignoreLowUniquenessWarning = false;
            window.ignoreBinningWarning = false;
            window.forceAggregatedLineChart = null;
            window.forceBinnedLineChart = null;
            
            // Show/hide cardinality warning for X-axis
            const xAxisHelp = document.getElementById('xAxisHelp');
            if (xAxisHelp && selectedPlotType === 'bar' && selectedXAxis) {
                const uniqueCount = getUniqueValueCount(selectedXAxis);
                if (uniqueCount > 50) {
                    xAxisHelp.style.display = 'block';
                } else {
                    xAxisHelp.style.display = 'none';
                }
            } else if (xAxisHelp) {
                xAxisHelp.style.display = 'none';
            }
            
            const plotPreview = document.querySelector('.plot-preview');
            const rangeControls = document.getElementById('rangeControls');
            if (!plotPreview) return;
            
            if (selectedPlotType && selectedXAxis && selectedYAxis) {
                // Check if the combination is valid
                const isValidCombination = validatePlotCombination(selectedPlotType, selectedXAxis, selectedYAxis);
                
                if (isValidCombination.valid) {
                    // Show range controls for numeric axes
                    if (rangeControls) {
                        const xAxisType = getEffectiveVariableType(selectedXAxis);
                        const yAxisType = getEffectiveVariableType(selectedYAxis);
                        
                        if (isNumericType(xAxisType) || isNumericType(yAxisType)) {
                            rangeControls.style.display = 'block';
                            updateRangeInfo(selectedXAxis, selectedYAxis);
                        } else {
                            rangeControls.style.display = 'none';
                        }
                    }
                    
                    // Show regression controls for scatter plots with numeric axes
                    const regressionControls = document.getElementById('regressionControls');
                    if (regressionControls) {
                        const xAxisType = getEffectiveVariableType(selectedXAxis);
                        const yAxisType = getEffectiveVariableType(selectedYAxis);
                        
                        if (selectedPlotType === 'scatter' && isNumericType(xAxisType) && isNumericType(yAxisType)) {
                            regressionControls.style.display = 'block';
                        } else {
                            regressionControls.style.display = 'none';
                            // Reset regression state when hiding controls
                            const regressionToggle = document.getElementById('regressionToggle');
                            if (regressionToggle) regressionToggle.checked = false;
                        }
                    }
                    
                    // Show aggregation controls for bar charts with mixed axis types
                    const aggregationControls = document.getElementById('aggregationControls');
                    if (aggregationControls) {
                        const xAxisType = getEffectiveVariableType(selectedXAxis);
                        const yAxisType = getEffectiveVariableType(selectedYAxis);
                        

                        
                        // Show aggregation for bar charts when we have any axis combination
                        // (improved logic to be more permissive)
                        if (selectedPlotType === 'bar' && selectedXAxis && selectedYAxis && selectedYAxis !== 'count') {
                            // Show aggregation controls (except for count, which doesn't need aggregation)
                            aggregationControls.style.display = 'block';
                            
                            // Update explanation based on data types
                            const aggregationExplanation = document.getElementById('aggregationExplanation');
                            if (aggregationExplanation) {
                                if (xAxisType === 'boolean' || yAxisType === 'boolean') {
                                    aggregationExplanation.innerHTML = `
                                        <strong>📋 Boolean Data Detected:</strong> Boolean values (True/False, 1/0, Yes/No) are converted to numbers (1 for True, 0 for False). 
                                        <br><strong>💡 Tip:</strong> Use "Sum" to count True values, or "Mean" to get the proportion/percentage of True values in each category.
                                    `;
                                } else {
                                    aggregationExplanation.innerHTML = `
                                        <strong>📋 Explanation:</strong> When you have multiple data points for each category (e.g., multiple passengers in each class), this setting determines how those values are combined into a single bar height.
                                    `;
                                }
                            }
                        } else {
                            aggregationControls.style.display = 'none';
                        }
                    }
                    
                    // Show histogram controls for histogram plots
                    const histogramControls = document.getElementById('histogramControls');
                    if (histogramControls) {
                        if (selectedPlotType === 'histogram' && selectedXAxis) {
                            histogramControls.style.display = 'block';
                            
                            // Handle custom bin count visibility
                            const binCountSelect = document.getElementById('histogramBinCount');
                            const customBinCountInput = document.getElementById('customBinCount');
                            if (binCountSelect && customBinCountInput) {
                                if (binCountSelect.value === 'custom') {
                                    customBinCountInput.style.display = 'block';
                                } else {
                                    customBinCountInput.style.display = 'none';
                                }
                            }
                        } else {
                            histogramControls.style.display = 'none';
                        }
                    }
                    
                    plotPreview.innerHTML = `
                        <div class="plot-controls">
                            <button class="reset-points-btn" onclick="resetExcludedPoints()" style="display: none;">
                                Reset Excluded Points
                            </button>
                        </div>
                        <div class="plot-container">
                            <canvas id="dynamicPlot"></canvas>
                        </div>
                    `;
                    
                    // Generate the plot
                    generatePlot(selectedPlotType, selectedXAxis, selectedYAxis);
                } else {
                    if (rangeControls) rangeControls.style.display = 'none';
                    const regressionControls = document.getElementById('regressionControls');
                    if (regressionControls) regressionControls.style.display = 'none';
                    const aggregationControls = document.getElementById('aggregationControls');
                    if (aggregationControls) aggregationControls.style.display = 'none';
                    let errorClass = 'preview-error';
                    let errorTitle = 'Invalid Configuration';
                    
                    if (isValidCombination.isCardinalityError) {
                        errorClass = 'preview-cardinality-error';
                        errorTitle = 'High Cardinality Warning';
                    } else if (isValidCombination.isAxisTypeError) {
                        errorClass = 'preview-axis-type-error';
                        errorTitle = `Invalid ${isValidCombination.problemAxis.charAt(0).toUpperCase() + isValidCombination.problemAxis.slice(1)} Configuration`;
                    } else if (isValidCombination.isLowUniquenessWarning) {
                        errorClass = 'preview-low-uniqueness-warning';
                        errorTitle = 'Low-Uniqueness Numeric Data';
                    } else if (isValidCombination.isCategoricalAggregationOption) {
                        errorClass = 'preview-categorical-aggregation-option';
                        errorTitle = 'Categorical X-Axis Aggregation';
                    } else if (isValidCombination.isHighCardinalityBinning) {
                        errorClass = 'preview-high-cardinality-binning';
                        errorTitle = 'High-Cardinality Binning Option';
                    } else if (isValidCombination.isTemporalSuggestion) {
                        errorClass = 'preview-temporal-suggestion';
                        errorTitle = 'Convert to Temporal Data';
                    } else if (isValidCombination.isHistogramBooleanWarning) {
                        errorClass = 'preview-histogram-boolean-warning';
                        errorTitle = 'Boolean Data Warning';
                    } else if (isValidCombination.isHistogramLowUniquenessWarning) {
                        errorClass = 'preview-histogram-low-uniqueness-warning';
                        errorTitle = 'Low Uniqueness Warning';
                    }
                    
                    plotPreview.innerHTML = `
                        <div class="${errorClass}">
                            <div class="preview-icon">⚠️</div>
                            <h4>${errorTitle}</h4>
                            <div class="error-message">${isValidCombination.message}</div>
                            ${isValidCombination.isCardinalityError ? `
                                <div class="cardinality-actions">
                                    <button class="range-btn secondary" onclick="showTopCategories('${selectedXAxis}')">
                                        🔝 Show Top 20 Categories
                                    </button>
                                    <button class="range-btn secondary" onclick="suggestAlternativePlot('${selectedXAxis}')">
                                        💡 Suggest Better Plot Type
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isAxisTypeError ? `
                                <div class="axis-type-actions">
                                    <button class="range-btn secondary" onclick="suggestAlternativePlotForAxis('${selectedPlotType}', '${selectedXAxis}', '${selectedYAxis}')">
                                        📊 Suggest Better Plot Type
                                    </button>
                                    <button class="range-btn secondary" onclick="goToDataTypesTab()">
                                        🔧 Override Data Types
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isLowUniquenessWarning ? `
                                <div class="low-uniqueness-actions">
                                    <button class="range-btn secondary" onclick="treatAsCategorical('${selectedXAxis}', '${selectedYAxis}')">
                                        📊 Treat as Categorical → Bar Chart
                                    </button>
                                    <button class="range-btn secondary" onclick="aggregateByXAxis('${selectedXAxis}', '${selectedYAxis}')">
                                        📈 Aggregate ${selectedYAxis} by ${selectedXAxis}
                                    </button>
                                    <button class="range-btn" onclick="showAnywayLineChart('${selectedXAxis}', '${selectedYAxis}')" style="background: #dc2626;">
                                        ⚠️ Show Anyway (Not Recommended)
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isCategoricalAggregationOption ? `
                                <div class="categorical-aggregation-actions">
                                    <button class="range-btn" onclick="aggregateByXAxis('${selectedXAxis}', '${selectedYAxis}')">
                                        📈 Aggregate ${selectedYAxis} by ${selectedXAxis}
                                    </button>
                                    <button class="range-btn secondary" onclick="treatAsCategorical('${selectedXAxis}', '${selectedYAxis}')">
                                        📊 Use Bar Chart Instead
                                    </button>
                                    <button class="range-btn secondary" onclick="goToDataTypesTab()">
                                        🔧 Override Data Types
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isHighCardinalityBinning ? `
                                <div class="high-cardinality-binning-actions">
                                    <button class="range-btn" onclick="binAndAggregateAuto('${selectedXAxis}', '${selectedYAxis}')">
                                        🚀 Bin and Aggregate Automatically
                                    </button>
                                    <button class="range-btn secondary" onclick="customBinAndAggregate('${selectedXAxis}', '${selectedYAxis}')">
                                        ⚙️ Customize Bin Size & Aggregation
                                    </button>
                                    <button class="range-btn" onclick="showAnywayRawValues('${selectedXAxis}', '${selectedYAxis}')" style="background: #dc2626;">
                                        👉 Show Anyway (Not Recommended)
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isTemporalSuggestion ? `
                                <div class="temporal-suggestion-actions">
                                    <button class="range-btn" onclick="convertToTemporal('${selectedXAxis}', '${selectedYAxis}', '${isValidCombination.temporalType}')">
                                        🕒 Convert to ${isValidCombination.temporalType.charAt(0).toUpperCase() + isValidCombination.temporalType.slice(1)}
                                    </button>
                                    <button class="range-btn secondary" onclick="plotAsTextWithWarning('${selectedXAxis}', '${selectedYAxis}')">
                                        📊 Plot as Text (Override)
                                    </button>
                                    <button class="range-btn secondary" onclick="goToDataTypesTab()">
                                        🔧 Manual Type Override
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isHistogramBooleanWarning ? `
                                <div class="histogram-boolean-warning-actions">
                                    <button class="range-btn" onclick="switchToBarChartFromHistogram('${selectedXAxis}')">
                                        📊 Switch to Bar Chart (Recommended)
                                    </button>
                                    <button class="range-btn secondary" onclick="plotHistogramAnyway('${selectedXAxis}', 'boolean')">
                                        📈 Plot Histogram Anyway
                                    </button>
                                    <button class="range-btn secondary" onclick="goToDataTypesTab()">
                                        🔧 Override Data Type
                                    </button>
                                </div>
                            ` : ''}
                            ${isValidCombination.isHistogramLowUniquenessWarning ? `
                                <div class="histogram-low-uniqueness-warning-actions">
                                    <button class="range-btn" onclick="switchToBarChartFromHistogram('${selectedXAxis}')">
                                        📊 Switch to Bar Chart (Recommended)
                                    </button>
                                    <button class="range-btn secondary" onclick="plotHistogramAnyway('${selectedXAxis}', 'low-uniqueness')">
                                        📈 Plot Histogram Anyway (${isValidCombination.uniqueCount} bins)
                                    </button>
                                    <button class="range-btn secondary" onclick="goToDataTypesTab()">
                                        🔧 Override Data Type
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            } else {
                if (rangeControls) rangeControls.style.display = 'none';
                const regressionControls = document.getElementById('regressionControls');
                if (regressionControls) regressionControls.style.display = 'none';
                const aggregationControls = document.getElementById('aggregationControls');
                if (aggregationControls) aggregationControls.style.display = 'none';
                plotPreview.innerHTML = `
                    <div class="preview-placeholder">
                        <div class="preview-icon">📊</div>
                        <p>Configure your plot settings above to see a preview</p>
                    </div>
                `;
            }
        }

        function updateRangeInfo(xAxis, yAxis) {
            const xAxisType = getEffectiveVariableType(xAxis);
            const yAxisType = getEffectiveVariableType(yAxis);
            
            if (isNumericType(xAxisType)) {
                const xValues = csvData.map(row => parseFloat(row[xAxis])).filter(v => !isNaN(v));
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                
                document.getElementById('xAxisRangeInfo').textContent = 
                    `Data range: ${xMin.toFixed(2)} to ${xMax.toFixed(2)}`;
                
                // Set placeholder values
                document.getElementById('xAxisMin').placeholder = xMin.toFixed(2);
                document.getElementById('xAxisMax').placeholder = xMax.toFixed(2);
            } else {
                document.getElementById('xAxisRangeInfo').textContent = 'Categorical data - range not applicable';
                document.getElementById('xAxisMin').placeholder = 'N/A';
                document.getElementById('xAxisMax').placeholder = 'N/A';
            }
            
            if (isNumericType(yAxisType)) {
                const yValues = csvData.map(row => parseFloat(row[yAxis])).filter(v => !isNaN(v));
                const yMin = Math.min(...yValues);
                const yMax = Math.max(...yValues);
                
                document.getElementById('yAxisRangeInfo').textContent = 
                    `Data range: ${yMin.toFixed(2)} to ${yMax.toFixed(2)}`;
                
                // Set placeholder values
                document.getElementById('yAxisMin').placeholder = yMin.toFixed(2);
                document.getElementById('yAxisMax').placeholder = yMax.toFixed(2);
            } else {
                document.getElementById('yAxisRangeInfo').textContent = 'Categorical data - range not applicable';
                document.getElementById('yAxisMin').placeholder = 'N/A';
                document.getElementById('yAxisMax').placeholder = 'N/A';
            }
        }

        function applyAxisRanges() {
            const xAxisMin = document.getElementById('xAxisMin').value;
            const xAxisMax = document.getElementById('xAxisMax').value;
            const yAxisMin = document.getElementById('yAxisMin').value;
            const yAxisMax = document.getElementById('yAxisMax').value;
            
            // Store the ranges in global variables
            window.currentAxisRanges = {
                x: { min: xAxisMin ? parseFloat(xAxisMin) : null, max: xAxisMax ? parseFloat(xAxisMax) : null },
                y: { min: yAxisMin ? parseFloat(yAxisMin) : null, max: yAxisMax ? parseFloat(yAxisMax) : null }
            };
            
            // Regenerate the plot with new ranges
            if (window.currentPlotConfig) {
                generatePlot(
                    window.currentPlotConfig.plotType,
                    window.currentPlotConfig.xAxis,
                    window.currentPlotConfig.yAxis
                );
            }
        }

        function resetAxisRanges() {
            // Clear the range inputs
            document.getElementById('xAxisMin').value = '';
            document.getElementById('xAxisMax').value = '';
            document.getElementById('yAxisMin').value = '';
            document.getElementById('yAxisMax').value = '';
            
            // Clear stored ranges
            window.currentAxisRanges = null;
            
            // Regenerate the plot with auto ranges
            if (window.currentPlotConfig) {
                generatePlot(
                    window.currentPlotConfig.plotType,
                    window.currentPlotConfig.xAxis,
                    window.currentPlotConfig.yAxis
                );
            }
        }

        function setDataRange() {
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');
            
            if (!plotTypeSelect || !xAxisSelect || !yAxisSelect) return;
            
            const selectedXAxis = xAxisSelect.value;
            const selectedYAxis = yAxisSelect.value;
            
            const xAxisType = getVariableType(selectedXAxis);
            const yAxisType = getVariableType(selectedYAxis);
            
            if (xAxisType === 'numeric') {
                const xValues = csvData.map(row => parseFloat(row[selectedXAxis])).filter(v => !isNaN(v));
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                
                document.getElementById('xAxisMin').value = xMin.toFixed(2);
                document.getElementById('xAxisMax').value = xMax.toFixed(2);
            }
            
            if (yAxisType === 'numeric') {
                const yValues = csvData.map(row => parseFloat(row[selectedYAxis])).filter(v => !isNaN(v));
                const yMin = Math.min(...yValues);
                const yMax = Math.max(...yValues);
                
                document.getElementById('yAxisMin').value = yMin.toFixed(2);
                document.getElementById('yAxisMax').value = yMax.toFixed(2);
            }
            
            // Apply the ranges
            applyAxisRanges();
        }



        function getPlotTypeDisplayName(plotType) {
            const displayNames = {
                'bar': 'Bar Chart',
                'line': 'Line Chart',
                'scatter': 'Scatter Plot',
                'histogram': 'Histogram'
            };
            return displayNames[plotType] || plotType;
        }

        function getUniqueValueCount(columnName) {
            if (!csvData || csvData.length === 0) return 0;
            const values = csvData.map(row => row[columnName]).filter(v => v !== '' && v !== null && v !== undefined);
            return new Set(values).size;
        }

        function validatePlotCombination(plotType, xAxis, yAxis) {
            const xAxisType = getEffectiveVariableType(xAxis);
            const yAxisType = yAxis === 'count' ? 'count' : getEffectiveVariableType(yAxis);
            
            // Smart type suggestion: Check if text columns appear to contain temporal data
            if (plotType === 'line' && !isTemporalType(xAxisType) && !isNumericType(xAxisType)) {
                const temporalPattern = isTextColumnTemporal(xAxis);
                if (temporalPattern && !window.ignoreTemporalSuggestion) {
                    return {
                        valid: false,
                        message: `🕒 <strong>Temporal Data Detected in X-Axis</strong><br><br>
                                 The column <strong>"${xAxis}"</strong> appears to contain <strong>${temporalPattern.type}</strong> values (${(temporalPattern.confidence * 100).toFixed(0)}% confidence).<br>
                                 <strong>Sample values:</strong> ${temporalPattern.sampleValues.join(', ')}<br><br>
                                 📈 <strong>To enable time-based line plotting:</strong><br>
                                 • Automatic chronological sorting<br>
                                 • Proper time-aware formatting<br>
                                 • Temporal aggregation options<br><br>
                                 <strong>👉 Choose your approach:</strong>`,
                        isTemporalSuggestion: true,
                        temporalType: temporalPattern.type,
                        xAxis: xAxis,
                        yAxis: yAxis,
                        confidence: temporalPattern.confidence
                    };
                }
            }
            
            switch (plotType) {
                case 'bar':
                    // Check for high cardinality first
                    const uniqueXValues = getUniqueValueCount(xAxis);
                    const cardinalityThreshold = 50;
                    
                    if (uniqueXValues > cardinalityThreshold) {
                        let suggestions = [];
                        
                        if (xAxisType === 'numeric') {
                            suggestions.push('📊 Use a <strong>Histogram</strong> to show the distribution of numeric values');
                            suggestions.push('📈 Use a <strong>Line Chart</strong> to show trends over values');
                        } else if (xAxisType === 'categorical') {
                            suggestions.push('🔝 Filter to show only the <strong>top 10-20 categories</strong> by frequency');
                            suggestions.push('📊 Use a <strong>Histogram</strong> if the categories represent ranges');
                        }
                        
                        if (getEffectiveVariableType(xAxis) === 'date' || xAxis.toLowerCase().includes('date') || xAxis.toLowerCase().includes('time')) {
                            suggestions.push('📈 Use a <strong>Line Chart</strong> to show trends over time');
                        }
                        
                        return {
                            valid: false,
                            message: `⚠️ <strong>Too many unique values in X-axis (${uniqueXValues} found).</strong><br>
                                     Bar charts work best with fewer than ${cardinalityThreshold} categories for readability.<br><br>
                                     <strong>💡 Suggestions:</strong><br>
                                     ${suggestions.length > 0 ? suggestions.join('<br>') : '• Consider grouping or filtering your data first'}`,
                            isCardinalityError: true
                        };
                    }
                    
                    // Bar charts work with categorical X and numeric/boolean/count Y
                    if (yAxis === 'count') {
                        return { 
                            valid: true, 
                            message: 'Counting the number of records in each category' 
                        };
                    } else if (xAxisType === 'categorical' && (yAxisType === 'numeric' || yAxisType === 'boolean')) {
                        return { 
                            valid: true, 
                            message: yAxisType === 'boolean' ? 'Boolean values will be treated as 0/1 for aggregation' : '' 
                        };
                    } else if (xAxisType === 'numeric' && (yAxisType === 'numeric' || yAxisType === 'boolean')) {
                        return { 
                            valid: true, 
                            message: `Note: Using numeric X-axis for bar chart${yAxisType === 'boolean' ? '. Boolean values treated as 0/1.' : ''}` 
                        };
                    } else if ((xAxisType === 'boolean' || xAxisType === 'categorical') && yAxisType === 'categorical') {
                        return { 
                            valid: false, 
                            message: 'Bar charts need at least one numeric or boolean axis. Text values cannot be aggregated.' 
                        };
                    } else {
                        return { 
                            valid: true, 
                            message: 'Chart will attempt to convert values to numeric where possible' 
                        };
                    }
                    
                case 'line':
                    // Line charts work with temporal/numeric X and numeric Y
                    if ((isNumericType(xAxisType) || isTemporalType(xAxisType)) && isNumericType(yAxisType)) {
                        const uniqueXValues = getUniqueValueCount(xAxis);
                        
                        // Check for high-cardinality numeric X-axis (needs binning)
                        const highCardinalityThreshold = 30;
                        if (!window.ignoreBinningWarning && uniqueXValues > highCardinalityThreshold) {
                            return {
                                valid: false,
                                message: `⚠️ <strong>High-Cardinality Numeric X-Axis Detected</strong><br><br>
                                         The X-axis column <strong>"${xAxis}"</strong> has <strong>${uniqueXValues} unique values</strong>. 
                                         Line charts work best when the X-axis is grouped into bins to show clear trends.<br><br>
                                         <strong>💡 Binning Solution:</strong> Group ${xAxis} values into intervals (e.g., "0-10", "10-20") 
                                         and aggregate ${yAxis} values within each bin.<br><br>
                                         <strong>👉 Choose your approach:</strong><br>
                                         • <strong>Bin and aggregate automatically</strong> (recommended)<br>
                                         • <strong>Customize bin size and aggregation method</strong><br>
                                         • Continue with raw values (may be hard to read)`,
                                isHighCardinalityBinning: true,
                                xAxis: xAxis,
                                yAxis: yAxis,
                                uniqueCount: uniqueXValues
                            };
                        }
                        
                        // Check for low-uniqueness numeric X-axis (might be categorical in disguise)
                        // Skip this check if user has explicitly chosen to ignore the warning
                        if (!window.ignoreLowUniquenessWarning && uniqueXValues < 10) {
                            return {
                                valid: false,
                                message: `⚠️ <strong>Low-Uniqueness Numeric X-Axis Detected</strong><br><br>
                                         The selected X-axis column <strong>"${xAxis}"</strong> is numeric but has only <strong>${uniqueXValues} unique values</strong>. 
                                         Line charts are intended for continuous numeric trends (e.g., time or measurements).<br><br>
                                         <strong>💭 This column may be categorical in disguise.</strong> Consider switching to a bar chart instead or aggregating values by ${xAxis}.<br><br>
                                         <strong>👉 Recommended actions:</strong><br>
                                         • Use a <strong>Bar Chart</strong> to show ${yAxis} across ${xAxis} categories<br>
                                         • <strong>Aggregate</strong> ${yAxis} by ${xAxis} (e.g., mean ${yAxis} per ${xAxis})<br>
                                         • Continue anyway (not recommended for meaningful insights)`,
                                isLowUniquenessWarning: true,
                                xAxis: xAxis,
                                yAxis: yAxis,
                                uniqueCount: uniqueXValues
                            };
                        }
                        
                        return { valid: true, message: '' };
                    } else if (!isNumericType(xAxisType) && isNumericType(yAxisType)) {
                        // Special case: Categorical X-axis with few categories can be aggregated for line charts
                        const uniqueXValues = getUniqueValueCount(xAxis);
                        const smallCategoricalThreshold = 10; // Allow up to 10 categories for aggregated line charts
                        
                        if (uniqueXValues <= smallCategoricalThreshold) {
                            return {
                                valid: false,
                                message: `⚠️ <strong>Categorical X-Axis with Aggregation Option</strong><br><br>
                                         The selected X-axis column <strong>"${xAxis}"</strong> is categorical with <strong>${uniqueXValues} categories</strong>. 
                                         While line charts typically require numeric X-axis, you can create an aggregated line chart.<br><br>
                                         <strong>💡 Aggregated Line Chart:</strong> This will show one point per category (e.g., average ${yAxis} for each ${xAxis}).<br><br>
                                         <strong>👉 Choose your approach:</strong><br>
                                         • <strong>Aggregate ${yAxis} by ${xAxis}</strong> → Line chart with ${uniqueXValues} points<br>
                                         • <strong>Use Bar Chart</strong> → Better for comparing categories<br>
                                         • <strong>Override data type</strong> if ${xAxis} should be numeric`,
                                isCategoricalAggregationOption: true,
                                xAxis: xAxis,
                                yAxis: yAxis,
                                uniqueCount: uniqueXValues
                            };
                        } else {
                            // Too many categories for meaningful aggregated line chart
                            return { 
                                valid: false, 
                                message: `⚠️ <strong>Invalid X-Axis Configuration for Line Chart</strong><br><br>
                                         Line charts require a numeric X-axis (e.g., time, age, passenger ID). The selected column <strong>"${xAxis}"</strong> is detected as <strong>${getTypeDisplayName(xAxisType)}</strong> with ${uniqueXValues} categories.<br><br>
                                         <strong>👉 Please either:</strong><br>
                                         • <strong>Change the plot type</strong> (e.g., use a bar chart), or<br>
                                         • <strong>Override the data type</strong> of "${xAxis}" to Numeric if appropriate (e.g., 1, 2, 3 for Pclass)<br><br>
                                         💡 <em>Tip: Go to the "Data Types" tab to override column types if needed.</em>`,
                                isAxisTypeError: true,
                                problemAxis: 'x-axis',
                                suggestedActions: ['change_plot_type', 'override_data_type']
                            };
                        }
                    } else if (!isNumericType(xAxisType)) {
                        return { 
                            valid: false, 
                            message: `⚠️ <strong>Invalid X-Axis Configuration for Line Chart</strong><br><br>
                                     Line charts require a numeric X-axis (e.g., time, age, passenger ID). The selected column <strong>"${xAxis}"</strong> is detected as <strong>${getTypeDisplayName(xAxisType)}</strong>.<br><br>
                                     <strong>👉 Please either:</strong><br>
                                     • <strong>Change the plot type</strong> (e.g., use a bar chart), or<br>
                                     • <strong>Override the data type</strong> of "${xAxis}" to Numeric if appropriate (e.g., 1, 2, 3 for Pclass)<br><br>
                                     💡 <em>Tip: Go to the "Data Types" tab to override column types if needed.</em>`,
                            isAxisTypeError: true,
                            problemAxis: 'x-axis',
                                                         suggestedActions: ['change_plot_type', 'override_data_type']
                         };
                    } else if (!isNumericType(yAxisType)) {
                        return { 
                            valid: false, 
                            message: `⚠️ <strong>Invalid Y-Axis Configuration for Line Chart</strong><br><br>
                                     Line charts require a numeric Y-axis. The selected column <strong>"${yAxis}"</strong> is detected as <strong>${getTypeDisplayName(yAxisType)}</strong>.<br><br>
                                     <strong>👉 Please either:</strong><br>
                                     • <strong>Change the plot type</strong> (e.g., use a bar chart), or<br>
                                     • <strong>Override the data type</strong> of "${yAxis}" to Numeric if appropriate<br><br>
                                     💡 <em>Tip: Go to the "Data Types" tab to override column types if needed.</em>`,
                            isAxisTypeError: true,
                            problemAxis: 'y-axis',
                            suggestedActions: ['change_plot_type', 'override_data_type']
                        };
                    } else {
                        return { 
                            valid: false, 
                            message: 'Line charts require numeric X-axis and numeric Y-axis' 
                        };
                    }
                    
                case 'scatter':
                    // Scatter plots work with numeric X and numeric Y (including integer, float, etc.)
                    if (isNumericType(xAxisType) && isNumericType(yAxisType)) {
                        return { valid: true, message: '' };
                    } else if (!isNumericType(xAxisType)) {
                        return { 
                            valid: false, 
                            message: `⚠️ <strong>Invalid X-Axis Configuration for Scatter Plot</strong><br><br>
                                     Scatter plots require a numeric X-axis to plot points. The selected column <strong>"${xAxis}"</strong> is detected as <strong>${getTypeDisplayName(xAxisType)}</strong>.<br><br>
                                     <strong>👉 Please either:</strong><br>
                                     • <strong>Change to a Bar Chart</strong> to show categories vs numeric values, or<br>
                                     • <strong>Override the data type</strong> of "${xAxis}" to Numeric if it contains numbers<br><br>
                                     💡 <em>Tip: Go to the "Data Types" tab to override column types if needed.</em>`,
                            isAxisTypeError: true,
                            problemAxis: 'x-axis',
                                                         suggestedActions: ['change_plot_type', 'override_data_type']
                         };
                    } else if (!isNumericType(yAxisType)) {
                        return { 
                            valid: false, 
                            message: `⚠️ <strong>Invalid Y-Axis Configuration for Scatter Plot</strong><br><br>
                                     Scatter plots require a numeric Y-axis to plot points. The selected column <strong>"${yAxis}"</strong> is detected as <strong>${getTypeDisplayName(yAxisType)}</strong>.<br><br>
                                     <strong>👉 Please either:</strong><br>
                                     • <strong>Change to a Bar Chart</strong> to show categories vs numeric values, or<br>
                                     • <strong>Override the data type</strong> of "${yAxis}" to Numeric if it contains numbers<br><br>
                                     💡 <em>Tip: Go to the "Data Types" tab to override column types if needed.</em>`,
                            isAxisTypeError: true,
                            problemAxis: 'y-axis',
                            suggestedActions: ['change_plot_type', 'override_data_type']
                        };
                    } else {
                        return { 
                            valid: false, 
                            message: 'Scatter plots require numeric X-axis and numeric Y-axis' 
                        };
                    }
                    
                case 'histogram':
                    // Histograms work with numeric data only (excluding boolean)
                    if (xAxisType === 'boolean' && !window.ignoreHistogramBooleanWarning) {
                        return {
                            valid: false,
                            message: `📊 <strong>Boolean Data Detected for Histogram</strong><br><br>
                                     The column <strong>"${xAxis}"</strong> is detected as Boolean (True/False, 0/1). 
                                     Histograms work best with continuous numeric data.<br><br>
                                     <strong>💡 Recommendation:</strong> Boolean data with only 2 values is better visualized with a Bar Chart 
                                     which will clearly show the count of True vs False values.<br><br>
                                     <strong>👉 Choose your approach:</strong>`,
                            isHistogramBooleanWarning: true,
                            xAxis: xAxis
                        };
                    } else if (isNumericType(xAxisType)) {
                        // Check for low uniqueness (too few unique values for meaningful histogram)
                        const uniqueCount = getUniqueValueCount(xAxis);
                        if (uniqueCount < 5 && !window.ignoreHistogramLowUniquenessWarning) {
                            return {
                                valid: false,
                                message: `📊 <strong>Low Uniqueness Detected for Histogram</strong><br><br>
                                         The column <strong>"${xAxis}"</strong> has only <strong>${uniqueCount} unique values</strong>. 
                                         Histograms work best with many unique numeric values to show meaningful distributions.<br><br>
                                         <strong>💡 Recommendation:</strong> With so few unique values, a Bar Chart will be more informative, 
                                         showing the exact count for each value.<br><br>
                                         <strong>👉 Choose your approach:</strong>`,
                                isHistogramLowUniquenessWarning: true,
                                xAxis: xAxis,
                                uniqueCount: uniqueCount
                            };
                        }
                        return { valid: true, message: 'Histogram shows distribution of X-axis values' };
                    } else {
                        return { 
                            valid: false, 
                            message: `⚠️ <strong>Invalid X-Axis Configuration for Histogram</strong><br><br>
                                     Histograms show the distribution of numeric values. The selected column <strong>"${xAxis}"</strong> is detected as <strong>${getTypeDisplayName(xAxisType)}</strong>.<br><br>
                                     <strong>👉 Please either:</strong><br>
                                     • <strong>Choose a numeric column</strong> for the X-axis (e.g., Age, Fare), or<br>
                                     • <strong>Use a Bar Chart</strong> to show the count of categorical values, or<br>
                                     • <strong>Override the data type</strong> if "${xAxis}" should be numeric<br><br>
                                     💡 <em>Tip: Bar charts are better for showing counts of categories.</em>`,
                            isAxisTypeError: true,
                            problemAxis: 'x-axis',
                            suggestedActions: ['change_plot_type', 'override_data_type']
                        };
                    }
                    

                    
                default:
                    return { valid: false, message: 'Unknown plot type' };
            }
        }

        // Global variables to track current plot configuration and excluded points
        window.currentPlotConfig = null;
        window.excludedPoints = new Set();

        function generatePlot(plotType, xAxis, yAxis) {
            const canvas = document.getElementById('dynamicPlot');
            if (!canvas) return;
            
            // Store current configuration (for histogram, yAxis is not needed)
            window.currentPlotConfig = { 
                plotType, 
                xAxis, 
                yAxis: plotType === 'histogram' ? null : yAxis 
            };
            
            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            
            switch (plotType) {
                case 'bar':
                    createBarChartDynamic(ctx, xAxis, yAxis);
                    break;
                case 'line':
                    createLineChartDynamic(ctx, xAxis, yAxis);
                    break;
                case 'scatter':
                    createScatterChartDynamic(ctx, xAxis, yAxis);
                    // Update regression analysis for scatter plots
                    updateRegressionAnalysis();
                    break;
                case 'histogram':
                    createHistogramChart(ctx, xAxis);
                    break;
            }
        }

        function regeneratePlot() {
            if (window.currentPlotConfig) {
                generatePlot(
                    window.currentPlotConfig.plotType,
                    window.currentPlotConfig.xAxis,
                    window.currentPlotConfig.yAxis
                );
            }
        }

        function removeDataPoint(index) {
            window.excludedPoints.add(index);
            
            // Show reset button if points are excluded
            const resetBtn = document.querySelector('.reset-points-btn');
            if (resetBtn) {
                resetBtn.style.display = 'block';
            }
            
            regeneratePlot();
        }

        function resetExcludedPoints() {
            window.excludedPoints.clear();
            
            // Hide reset button
            const resetBtn = document.querySelector('.reset-points-btn');
            if (resetBtn) {
                resetBtn.style.display = 'none';
            }
            
            regeneratePlot();
        }

        function convertToNumeric(value, variableType) {
            // Handle Boolean values
            if (variableType === 'boolean') {
                const normalizedValue = value.toString().toLowerCase().trim();
                if (['1', 'true', 'yes', 'y', 'alive', 'survived'].includes(normalizedValue)) {
                    return 1;
                } else if (['0', 'false', 'no', 'n', 'dead', 'died'].includes(normalizedValue)) {
                    return 0;
                }
            }
            
            // Handle numeric values
            const numericValue = parseFloat(value);
            return isNaN(numericValue) ? null : numericValue;
        }

        function createBarChartDynamic(ctx, xAxis, yAxis) {
            const xAxisType = getEffectiveVariableType(xAxis);
            const yAxisType = yAxis === 'count' ? 'count' : getEffectiveVariableType(yAxis);
            let labels, data, chartTitle;
            
            // Handle count case first
            if (yAxis === 'count') {
                // Count records in each X-axis category
                const groupedData = {};
                csvData.forEach(row => {
                    const category = row[xAxis];
                    if (category !== '' && category !== null && category !== undefined) {
                        if (!groupedData[category]) {
                            groupedData[category] = 0;
                        }
                        groupedData[category]++;
                    }
                });
                
                labels = Object.keys(groupedData);
                data = Object.values(groupedData);
                chartTitle = `Count of Records by ${xAxis}`;
                
            } else if (isCategoricalType(xAxisType) && isNumericType(yAxisType)) {
                // X-axis categorical, Y-axis numeric/boolean: group by X-axis categories
                const groupedData = {};
                csvData.forEach(row => {
                    const category = row[xAxis];
                    const value = convertToNumeric(row[yAxis], yAxisType);
                    if (value !== null && category !== '' && category !== null && category !== undefined) {
                        if (!groupedData[category]) {
                            groupedData[category] = [];
                        }
                        groupedData[category].push(value);
                    }
                });
                
                labels = Object.keys(groupedData);
                const aggregationMethod = getSelectedAggregationMethod();
                data = labels.map(category => {
                    const values = groupedData[category];
                    return applyAggregation(values, aggregationMethod);
                });
                const yAxisLabel = yAxisType === 'boolean' ? `${yAxis} (0/1)` : yAxis;
                chartTitle = `${getAggregationDisplayName(aggregationMethod)} of ${yAxisLabel} by ${xAxis}`;
                
            } else if (isNumericType(xAxisType) && isCategoricalType(yAxisType)) {
                // X-axis numeric/boolean, Y-axis categorical: group by Y-axis categories
                const groupedData = {};
                csvData.forEach(row => {
                    const category = row[yAxis];
                    const value = convertToNumeric(row[xAxis], xAxisType);
                    if (value !== null && category !== '' && category !== null && category !== undefined) {
                        if (!groupedData[category]) {
                            groupedData[category] = [];
                        }
                        groupedData[category].push(value);
                    }
                });
                
                labels = Object.keys(groupedData);
                const aggregationMethod = getSelectedAggregationMethod();
                data = labels.map(category => {
                    const values = groupedData[category];
                    return applyAggregation(values, aggregationMethod);
                });
                const xAxisLabel = xAxisType === 'boolean' ? `${xAxis} (0/1)` : xAxis;
                chartTitle = `${getAggregationDisplayName(aggregationMethod)} of ${xAxisLabel} by ${yAxis}`;
                
            } else {
                // For numeric/boolean vs numeric/boolean, use first 20 values
                const validData = csvData
                    .map(row => ({ 
                        x: convertToNumeric(row[xAxis], xAxisType), 
                        y: convertToNumeric(row[yAxis], yAxisType) 
                    }))
                    .filter(point => point.x !== null && point.y !== null)
                    .slice(0, 20);
                
                labels = validData.map(point => point.x.toString());
                data = validData.map(point => point.y);
                chartTitle = `${yAxis} by ${xAxis}`;
            }
            
            // Apply axis ranges if set
            const scales = {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: yAxis === 'count' ? 'Count' : (yAxisType === 'boolean' ? `${yAxis} (0/1)` : yAxis)
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: xAxis
                    }
                }
            };
            
            // Apply custom ranges if set
            if (window.currentAxisRanges) {
                if (window.currentAxisRanges.y.min !== null) {
                    scales.y.min = window.currentAxisRanges.y.min;
                }
                if (window.currentAxisRanges.y.max !== null) {
                    scales.y.max = window.currentAxisRanges.y.max;
                }
                if (isNumericType(xAxisType) && window.currentAxisRanges.x.min !== null) {
                    scales.x.min = window.currentAxisRanges.x.min;
                }
                if (isNumericType(xAxisType) && window.currentAxisRanges.x.max !== null) {
                    scales.x.max = window.currentAxisRanges.x.max;
                }
            }
            
            window.currentChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: yAxis === 'count' ? 'Count' : yAxis,
                        data: data,
                        backgroundColor: 'rgba(79, 70, 229, 0.8)',
                        borderColor: 'rgba(79, 70, 229, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle || `${yAxis} by ${xAxis}`
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: scales
                }
            });
        }

        function createLineChartDynamic(ctx, xAxis, yAxis) {
            const xAxisType = getEffectiveVariableType(xAxis);
            
            // Handle temporal X-axis
            if (isTemporalType(xAxisType)) {
                generateTemporalLineChart(xAxis, yAxis, xAxisType);
                return;
            }
            
            const validData = csvData
                .map((row, index) => ({ 
                    x: parseFloat(row[xAxis]), 
                    y: parseFloat(row[yAxis]),
                    originalIndex: index 
                }))
                .filter(point => !isNaN(point.x) && !isNaN(point.y))
                .filter((point, index) => !window.excludedPoints.has(point.originalIndex))
                .sort((a, b) => a.x - b.x);
            
            // Apply axis range filtering if ranges are set
            let displayData = validData;
            if (window.currentAxisRanges) {
                displayData = validData.filter(point => {
                    let includePoint = true;
                    
                    if (window.currentAxisRanges.x.min !== null && point.x < window.currentAxisRanges.x.min) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.x.max !== null && point.x > window.currentAxisRanges.x.max) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.y.min !== null && point.y < window.currentAxisRanges.y.min) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.y.max !== null && point.y > window.currentAxisRanges.y.max) {
                        includePoint = false;
                    }
                    
                    return includePoint;
                });
            }
            
            // Only limit data points if no custom ranges are set and we have too many points
            if (!window.currentAxisRanges && displayData.length > 200) {
                // Sample data points evenly across the range instead of just taking the first 200
                const step = Math.floor(displayData.length / 200);
                displayData = displayData.filter((_, index) => index % step === 0).slice(0, 200);
            }
            
            const labels = displayData.map(point => point.x.toString());
            const data = displayData.map(point => point.y);
            
            window.currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: yAxis,
                        data: data,
                        borderColor: 'rgba(124, 58, 237, 1)',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointBackgroundColor: 'rgba(124, 58, 237, 1)',
                        pointBorderColor: 'rgba(124, 58, 237, 1)',
                        pointBorderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${yAxis} vs ${xAxis}${window.excludedPoints.size > 0 ? ` (${window.excludedPoints.size} points excluded)` : ''}${window.currentAxisRanges ? ` (${displayData.length} points in range)` : ''}`
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const originalIndex = validData[dataIndex]?.originalIndex;
                                    return originalIndex !== undefined ? 
                                        `Click to remove this point` : '';
                                }
                            }
                        }
                    },
                    scales: (() => {
                        const scales = {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: yAxis
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: xAxis
                                }
                            }
                        };
                        
                        // Apply custom ranges if set
                        if (window.currentAxisRanges) {
                            if (window.currentAxisRanges.y.min !== null) {
                                scales.y.min = window.currentAxisRanges.y.min;
                            }
                            if (window.currentAxisRanges.y.max !== null) {
                                scales.y.max = window.currentAxisRanges.y.max;
                            }
                            if (window.currentAxisRanges.x.min !== null) {
                                scales.x.min = window.currentAxisRanges.x.min;
                            }
                            if (window.currentAxisRanges.x.max !== null) {
                                scales.x.max = window.currentAxisRanges.x.max;
                            }
                        }
                        
                        return scales;
                    })(),
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const originalIndex = validData[dataIndex]?.originalIndex;
                            if (originalIndex !== undefined) {
                                removeDataPoint(originalIndex);
                            }
                        }
                    }
                }
            });
        }

        function createScatterChartDynamic(ctx, xAxis, yAxis) {
            const validData = csvData
                .map((row, index) => ({ 
                    x: parseFloat(row[xAxis]), 
                    y: parseFloat(row[yAxis]),
                    originalIndex: index 
                }))
                .filter(point => !isNaN(point.x) && !isNaN(point.y))
                .filter((point, index) => !window.excludedPoints.has(point.originalIndex));
            
            // Apply axis range filtering if ranges are set
            let displayData = validData;
            if (window.currentAxisRanges) {
                displayData = validData.filter(point => {
                    let includePoint = true;
                    
                    if (window.currentAxisRanges.x.min !== null && point.x < window.currentAxisRanges.x.min) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.x.max !== null && point.x > window.currentAxisRanges.x.max) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.y.min !== null && point.y < window.currentAxisRanges.y.min) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.y.max !== null && point.y > window.currentAxisRanges.y.max) {
                        includePoint = false;
                    }
                    
                    return includePoint;
                });
            }
            
            // Only limit data points if no custom ranges are set and we have too many points
            if (!window.currentAxisRanges && displayData.length > 300) {
                // Sample data points evenly across the range instead of just taking the first 300
                const step = Math.floor(displayData.length / 300);
                displayData = displayData.filter((_, index) => index % step === 0).slice(0, 300);
            }
            
            // Prepare datasets array
            const datasets = [{
                label: `${yAxis} vs ${xAxis}`,
                data: displayData,
                backgroundColor: 'rgba(59, 130, 246, 0.6)',
                borderColor: 'rgba(59, 130, 246, 1)',
                borderWidth: 1,
                pointRadius: 6,
                pointHoverRadius: 8
            }];
            
            // Add regression line if toggle is checked
            const regressionToggle = document.getElementById('regressionToggle');
            if (regressionToggle && regressionToggle.checked && window.currentRegression) {
                const xData = displayData.map(point => point.x);
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                
                const regressionLineData = [
                    { x: xMin, y: window.currentRegression.slope * xMin + window.currentRegression.intercept },
                    { x: xMax, y: window.currentRegression.slope * xMax + window.currentRegression.intercept }
                ];
                
                datasets.push({
                    label: 'Line of Best Fit',
                    data: regressionLineData,
                    type: 'line',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    fill: false,
                    tension: 0
                });
            }
            
            window.currentChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${yAxis} vs ${xAxis}${window.excludedPoints.size > 0 ? ` (${window.excludedPoints.size} points excluded)` : ''}${window.currentAxisRanges ? ` (${displayData.length} points in range)` : ''}`
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const originalIndex = displayData[dataIndex]?.originalIndex;
                                    return originalIndex !== undefined ? 
                                        `Click to remove this point` : '';
                                }
                            }
                        }
                    },
                    scales: (() => {
                        const scales = {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: yAxis
                                }
                            },
                            x: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: xAxis
                                }
                            }
                        };
                        
                        // Apply custom ranges if set
                        if (window.currentAxisRanges) {
                            if (window.currentAxisRanges.y.min !== null) {
                                scales.y.min = window.currentAxisRanges.y.min;
                            }
                            if (window.currentAxisRanges.y.max !== null) {
                                scales.y.max = window.currentAxisRanges.y.max;
                            }
                            if (window.currentAxisRanges.x.min !== null) {
                                scales.x.min = window.currentAxisRanges.x.min;
                            }
                            if (window.currentAxisRanges.x.max !== null) {
                                scales.x.max = window.currentAxisRanges.x.max;
                            }
                        }
                        
                        return scales;
                    })(),
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const originalIndex = displayData[dataIndex]?.originalIndex;
                            if (originalIndex !== undefined) {
                                removeDataPoint(originalIndex);
                            }
                        }
                    }
                }
            });
        }

        function createHistogramChart(ctx, xAxis) {
            // Get configuration values
            const binCountSelect = document.getElementById('histogramBinCount');
            const customBinCountInput = document.getElementById('customBinCount');
            const normalizationSelect = document.getElementById('histogramNormalization');
            
            let binCount = 10; // default
            if (binCountSelect) {
                if (binCountSelect.value === 'custom' && customBinCountInput && customBinCountInput.value) {
                    binCount = parseInt(customBinCountInput.value) || 10;
                } else if (binCountSelect.value !== 'custom') {
                    binCount = parseInt(binCountSelect.value) || 10;
                }
            }
            
            const isNormalized = normalizationSelect && normalizationSelect.value === 'percent';
            
            // Filter and prepare values (excluding missing values)
            const values = csvData
                .map(row => parseFloat(row[xAxis]))
                .filter(val => !isNaN(val));
            
            if (values.length === 0) {
                // Show no data message
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    plotPreview.innerHTML = `
                        <div class="preview-error">
                            <div class="preview-icon">❌</div>
                            <h4>No Valid Data</h4>
                            <p>No numeric values found in column <strong>"${xAxis}"</strong> after excluding missing values.</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Create histogram bins
            const min = Math.min(...values);
            const max = Math.max(...values);
            const binSize = (max - min) / binCount;
            
            const bins = new Array(binCount).fill(0);
            const binLabels = [];
            
            for (let i = 0; i < binCount; i++) {
                const binStart = min + i * binSize;
                const binEnd = min + (i + 1) * binSize;
                
                // Format bin labels based on value ranges
                if (binSize >= 1) {
                    binLabels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
                } else if (binSize >= 0.1) {
                    binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
                } else {
                    binLabels.push(`${binStart.toFixed(3)}-${binEnd.toFixed(3)}`);
                }
                
                // Count values in this bin
                values.forEach(value => {
                    if (i === binCount - 1) {
                        // Include max value in the last bin
                        if (value >= binStart && value <= binEnd) {
                            bins[i]++;
                        }
                    } else {
                        if (value >= binStart && value < binEnd) {
                            bins[i]++;
                        }
                    }
                });
            }
            
            // Convert to percentages if normalized
            const displayData = isNormalized ? 
                bins.map(count => (count / values.length * 100)) : 
                bins;
            
            const yAxisLabel = isNormalized ? 'Percentage (%)' : 'Frequency';
            const datasetLabel = isNormalized ? `Percentage of ${xAxis}` : `Frequency of ${xAxis}`;
            
            window.currentChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: datasetLabel,
                        data: displayData,
                        backgroundColor: 'rgba(16, 185, 129, 0.8)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Distribution of ${xAxis} (${binCount} bins${isNormalized ? ', normalized' : ''})`
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const binIndex = context.dataIndex;
                                    const actualCount = bins[binIndex];
                                    if (isNormalized) {
                                        return `Count: ${actualCount}`;
                                    }
                                    return `Total values: ${values.length}`;
                                }
                            }
                        }
                    },
                    scales: (() => {
                        const scales = {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: yAxisLabel
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: `${xAxis} (${values.length} values, ${csvData.length - values.length} excluded)`
                                }
                            }
                        };
                        
                        // Apply custom ranges if set (only Y-axis for histograms)
                        if (window.currentAxisRanges) {
                            if (window.currentAxisRanges.y.min !== null) {
                                scales.y.min = window.currentAxisRanges.y.min;
                            }
                            if (window.currentAxisRanges.y.max !== null) {
                                scales.y.max = window.currentAxisRanges.y.max;
                            }
                        }
                        
                        return scales;
                    })()
                }
            });
        }

        // Histogram warning and control functions
        function switchToBarChartFromHistogram(xAxis) {
            // Switch to bar chart
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');
            
            if (plotTypeSelect && yAxisSelect) {
                plotTypeSelect.value = 'bar';
                yAxisSelect.value = 'count'; // Set Y-axis to count for bar chart
                updatePlotConfiguration();
                
                // Show success message
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    setTimeout(() => {
                        const previewContent = plotPreview.querySelector('.preview-placeholder, .preview-ready, .preview-error, .preview-histogram-boolean-warning, .preview-histogram-low-uniqueness-warning');
                        if (previewContent) {
                            previewContent.innerHTML = `
                                <div class="preview-icon">✅</div>
                                <h4>Switched to Bar Chart</h4>
                                <p>Now showing count of records for each <strong>${xAxis}</strong> value. This is perfect for categorical or low-uniqueness data.</p>
                                <p>Configure any additional settings below.</p>
                            `;
                            previewContent.className = 'preview-ready';
                        }
                    }, 100);
                }
            }
        }

        function plotHistogramAnyway(xAxis, warningType) {
            // Set override flags to bypass warnings
            if (warningType === 'boolean') {
                window.ignoreHistogramBooleanWarning = true;
            } else if (warningType === 'low-uniqueness') {
                window.ignoreHistogramLowUniquenessWarning = true;
            }
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">📊</div>
                        <h4>Histogram (Warning Override)</h4>
                        <p>Showing histogram for <strong>${xAxis}</strong> despite ${warningType === 'boolean' ? 'boolean data' : 'low uniqueness'} warning.</p>
                        <p>⚠️ <em>Results may not be as informative as a bar chart for this data type.</em></p>
                        <button class="range-btn secondary" onclick="removeHistogramOverride('${xAxis}', '${warningType}')" style="margin-top: 1rem;">
                            🔄 Re-enable Warning
                        </button>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate the histogram
                const canvas = document.getElementById('dynamicPlot');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    createHistogramChart(ctx, xAxis);
                }
            }
        }

        function removeHistogramOverride(xAxis, warningType) {
            // Remove the override flags
            if (warningType === 'boolean') {
                window.ignoreHistogramBooleanWarning = false;
            } else if (warningType === 'low-uniqueness') {
                window.ignoreHistogramLowUniquenessWarning = false;
            }
            
            // Refresh the axis preview to show warning again
            updateAxisPreview();
        }

        function updateHistogram() {
            // Handle custom bin count visibility
            const binCountSelect = document.getElementById('histogramBinCount');
            const customBinCountInput = document.getElementById('customBinCount');
            
            if (binCountSelect && customBinCountInput) {
                if (binCountSelect.value === 'custom') {
                    customBinCountInput.style.display = 'block';
                    
                    // Only set default value if field is empty AND user isn't actively typing
                    if (!customBinCountInput.value && !window.userIsTyping) {
                        customBinCountInput.value = '10'; // default
                    }
                    
                    // Validate custom input
                    const customValue = parseInt(customBinCountInput.value);
                    if (customBinCountInput.value && customValue && (customValue < 2 || customValue > 100)) {
                        customBinCountInput.style.borderColor = '#ef4444';
                        customBinCountInput.title = 'Bin count must be between 2 and 100';
                        return; // Don't update chart with invalid values
                    } else {
                        customBinCountInput.style.borderColor = '#d1d5db';
                        customBinCountInput.title = '';
                    }
                } else {
                    customBinCountInput.style.display = 'none';
                    customBinCountInput.style.borderColor = '#d1d5db';
                    customBinCountInput.title = '';
                }
            }
            
            // Debounce rapid updates (wait for user to stop typing)
            clearTimeout(window.histogramUpdateTimeout);
            window.histogramUpdateTimeout = setTimeout(() => {
                // Regenerate the current histogram if one is active
                if (window.currentPlotConfig && window.currentPlotConfig.plotType === 'histogram') {
                    const canvas = document.getElementById('dynamicPlot');
                    if (canvas) {
                        // Destroy existing chart
                        if (window.currentChart) {
                            window.currentChart.destroy();
                        }
                        const ctx = canvas.getContext('2d');
                        createHistogramChart(ctx, window.currentPlotConfig.xAxis);
                    }
                }
            }, 800); // Wait 800ms after user stops typing
        }





        function analyzeMissingData() {
            const missingData = [];
            
            headers.forEach(header => {
                const missing = csvData.filter(row => !row[header] || row[header] === '').length;
                const percentage = ((missing / csvData.length) * 100).toFixed(1);
                
                if (missing > 0) {
                    missingData.push({
                        column: header,
                        missing: missing,
                        percentage: percentage
                    });
                }
            });
            
            return missingData.sort((a, b) => b.missing - a.missing);
        }

        function calculateCorrelations() {
            const numericColumns = headers.filter(header => {
                return isNumericType(getEffectiveVariableType(header)) && !shouldIgnoreColumn(getEffectiveVariableType(header));
            });

            if (numericColumns.length < 2) return [];

            const correlations = numericColumns.map(col1 => {
                const correlations = numericColumns.map(col2 => {
                    if (col1 === col2) return 1;
                    
                    const values1 = csvData.map(row => parseFloat(row[col1])).filter(v => !isNaN(v));
                    const values2 = csvData.map(row => parseFloat(row[col2])).filter(v => !isNaN(v));
                    
                    if (values1.length !== values2.length || values1.length === 0) return 0;
                    
                    return calculatePearsonCorrelation(values1, values2);
                });
                
                return {
                    column: col1,
                    correlations: correlations
                };
            });
            
            return correlations;
        }

        function calculatePearsonCorrelation(x, y) {
            const n = x.length;
            if (n !== y.length) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }

        function calculateCorrelationsEnhanced() {
            const settings = window.correlationSettings || {};
            const selectedColumns = settings.selectedColumns || [];
            
            if (selectedColumns.length < 2) return { matrix: [], columns: [], sampleSize: 0 };
            
            // Get data based on null handling preference
            let dataToUse = csvData;
            if (settings.excludeNulls) {
                // Filter out rows that have null/missing values in ANY of the selected columns
                dataToUse = csvData.filter(row => {
                    return selectedColumns.every(col => {
                        const value = row[col];
                        return value !== null && value !== undefined && value !== '' && !isNaN(parseFloat(value));
                    });
                });
            }
            
            const sampleSize = dataToUse.length;
            if (sampleSize === 0) return { matrix: [], columns: [], sampleSize: 0 };
            
            // Calculate correlation matrix
            const matrix = selectedColumns.map(col1 => {
                return selectedColumns.map(col2 => {
                    if (col1 === col2) return 1.0;
                    
                    let values1, values2;
                    if (settings.excludeNulls) {
                        // Use pre-filtered data
                        values1 = dataToUse.map(row => parseFloat(row[col1]));
                        values2 = dataToUse.map(row => parseFloat(row[col2]));
                    } else {
                        // Pairwise deletion - filter per pair
                        const pairs = csvData
                            .map(row => ({
                                x: parseFloat(row[col1]),
                                y: parseFloat(row[col2])
                            }))
                            .filter(pair => !isNaN(pair.x) && !isNaN(pair.y));
                        
                        values1 = pairs.map(pair => pair.x);
                        values2 = pairs.map(pair => pair.y);
                    }
                    
                    if (values1.length < 2) return 0;
                    return calculatePearsonCorrelation(values1, values2);
                });
            });
            
            // Sort columns if requested
            let sortedColumns = [...selectedColumns];
            let sortedMatrix = matrix.map(row => [...row]);
            
            if (settings.sortBy === 'alphabetical') {
                const sortOrder = sortedColumns
                    .map((col, index) => ({ col, index }))
                    .sort((a, b) => a.col.localeCompare(b.col));
                
                sortedColumns = sortOrder.map(item => item.col);
                sortedMatrix = sortOrder.map(item => 
                    sortOrder.map(item2 => matrix[item.index][item2.index])
                );
            } else if (settings.sortBy === 'strongest') {
                // Calculate average absolute correlation for each column
                const avgCorrelations = sortedColumns.map((col, index) => {
                    const rowCorrs = matrix[index].filter((_, i) => i !== index); // exclude self-correlation
                    const avgAbsCorr = rowCorrs.reduce((sum, corr) => sum + Math.abs(corr), 0) / rowCorrs.length;
                    return { col, index, avgAbsCorr };
                });
                
                const sortOrder = avgCorrelations.sort((a, b) => b.avgAbsCorr - a.avgAbsCorr);
                sortedColumns = sortOrder.map(item => item.col);
                sortedMatrix = sortOrder.map(item => 
                    sortOrder.map(item2 => matrix[item.index][item2.index])
                );
            }
            
            // Find strongest correlation (excluding diagonal)
            let strongestCorr = null;
            for (let i = 0; i < sortedMatrix.length; i++) {
                for (let j = i + 1; j < sortedMatrix[i].length; j++) {
                    const corr = Math.abs(sortedMatrix[i][j]);
                    if (!strongestCorr || corr > Math.abs(strongestCorr.value)) {
                        strongestCorr = {
                            value: sortedMatrix[i][j],
                            col1: sortedColumns[i],
                            col2: sortedColumns[j]
                        };
                    }
                }
            }
            
            return {
                matrix: sortedMatrix,
                columns: sortedColumns,
                sampleSize: sampleSize,
                strongestCorr: strongestCorr
            };
        }

        function getCorrelationColor(correlation) {
            // Diverging color scheme: Blue (positive) -> White (zero) -> Red (negative)
            const absCorr = Math.abs(correlation);
            const isPositive = correlation >= 0;
            
            if (absCorr < 0.01) {
                // Very close to zero - pure white
                return '#ffffff';
            }
            
            // Scale color intensity based on absolute correlation
            const intensity = Math.min(absCorr, 1.0);
            
            if (isPositive) {
                // Positive correlations: white to blue
                const blue = Math.round(31 + (224 * intensity)); // 31 to 255
                const green = Math.round(119 + (136 * (1 - intensity))); // 255 to 119  
                const red = Math.round(255 * (1 - intensity)); // 255 to 0
                return `rgb(${red}, ${green}, ${blue})`;
            } else {
                // Negative correlations: white to red
                const red = Math.round(214 + (41 * intensity)); // 214 to 255
                const green = Math.round(255 * (1 - intensity)); // 255 to 0
                const blue = Math.round(255 * (1 - intensity)); // 255 to 0
                return `rgb(${red}, ${green}, ${blue})`;
            }
        }

        function getCorrelationTextColor(correlation) {
            const absCorr = Math.abs(correlation);
            // Use dark text for light backgrounds, white text for dark backgrounds
            if (absCorr > 0.6) {
                return '#ffffff'; // White text for strong correlations
            } else {
                return '#1f2937'; // Dark text for weak correlations
            }
        }

        function showCorrelationTooltip(event) {
            const tooltip = document.getElementById('correlationTooltip');
            const cell = event.target;
            
            const col1 = cell.dataset.col1;
            const col2 = cell.dataset.col2;
            const corr = parseFloat(cell.dataset.corr);
            const sampleSize = cell.dataset.sampleSize;
            
            const absCorr = Math.abs(corr);
            let strength = 'Negligible';
            if (absCorr > 0.5) strength = 'Strong';
            else if (absCorr > 0.3) strength = 'Moderate';
            else if (absCorr > 0.1) strength = 'Weak';
            
            const direction = corr > 0 ? 'Positive' : corr < 0 ? 'Negative' : 'None';
            
            tooltip.innerHTML = `
                <strong>${col1} ↔ ${col2}</strong><br>
                Correlation: <strong>${corr.toFixed(4)}</strong><br>
                Strength: <strong>${strength}</strong><br>
                Direction: <strong>${direction}</strong><br>
                Sample size: <strong>${sampleSize} rows</strong>
            `;
            
            tooltip.classList.add('visible');
            moveCorrelationTooltip(event);
        }

        function hideCorrelationTooltip() {
            const tooltip = document.getElementById('correlationTooltip');
            tooltip.classList.remove('visible');
        }

        function moveCorrelationTooltip(event) {
            const tooltip = document.getElementById('correlationTooltip');
            const offset = 10;
            
            tooltip.style.left = (event.clientX + offset) + 'px';
            tooltip.style.top = (event.clientY + offset) + 'px';
        }

        function exportCorrelationCSV() {
            const correlationData = calculateCorrelationsEnhanced();
            
            if (correlationData.matrix.length === 0) {
                alert('No correlation data available to export. Please ensure you have selected at least 2 numeric columns.');
                return;
            }

            // Create CSV content
            let csvContent = '';
            
            // Add metadata as comments
            csvContent += `# Correlation Matrix Export\n`;
            csvContent += `# Generated: ${new Date().toISOString()}\n`;
            csvContent += `# Sample size: ${correlationData.sampleSize} rows\n`;
            csvContent += `# Missing values: ${window.correlationSettings.excludeNulls ? 'Excluded (listwise deletion)' : 'Handled pairwise'}\n`;
            csvContent += `# Matrix size: ${correlationData.columns.length}×${correlationData.columns.length}\n`;
            if (correlationData.strongestCorr) {
                csvContent += `# Strongest correlation: ${correlationData.strongestCorr.value.toFixed(4)} (${correlationData.strongestCorr.col1} ↔ ${correlationData.strongestCorr.col2})\n`;
            }
            csvContent += `\n`;
            
            // Add header row
            csvContent += 'Variable,' + correlationData.columns.join(',') + '\n';
            
            // Add data rows
            correlationData.matrix.forEach((row, i) => {
                const rowData = [correlationData.columns[i], ...row.map(val => val.toFixed(3))];
                csvContent += rowData.join(',') + '\n';
            });

            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `correlation_matrix_${timestamp}.csv`;
            
            if (link.download !== undefined) {
                link.setAttribute('href', URL.createObjectURL(blob));
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Show success message
                showExportSuccess('CSV', filename);
            } else {
                alert('CSV download not supported in this browser.');
            }
        }

        function exportCorrelationPNG() {
            // Check if html2canvas is available
            if (typeof html2canvas === 'undefined') {
                alert('PNG export functionality is not available. Please refresh the page and try again.');
                return;
            }

            const correlationContent = document.getElementById('correlationContent');
            if (!correlationContent) {
                alert('No correlation matrix available to export.');
                return;
            }

            // Show export progress
            showExportProgress('PNG');

            // Configuration for html2canvas
            const options = {
                backgroundColor: '#ffffff',
                scale: 2, // Higher resolution
                useCORS: true,
                allowTaint: true,
                width: correlationContent.scrollWidth,
                height: correlationContent.scrollHeight,
                scrollX: 0,
                scrollY: 0,
                onclone: function(clonedDoc) {
                    // Ensure tooltips are hidden in the clone
                    const tooltip = clonedDoc.getElementById('correlationTooltip');
                    if (tooltip) {
                        tooltip.style.display = 'none';
                    }
                    
                    // Fix any scrollable content to show all
                    const tableContainer = clonedDoc.querySelector('.correlation-table-container');
                    if (tableContainer) {
                        tableContainer.style.overflow = 'visible';
                        tableContainer.style.maxWidth = 'none';
                    }
                }
            };

            html2canvas(correlationContent, options)
                .then(canvas => {
                    // Create download link
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `correlation_matrix_${timestamp}.png`;
                    
                    link.download = filename;
                    link.href = canvas.toDataURL('image/png');
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    hideExportProgress();
                    showExportSuccess('PNG', filename);
                })
                .catch(error => {
                    console.error('PNG export failed:', error);
                    hideExportProgress();
                    alert('Failed to export PNG. Please try again or use CSV export instead.');
                });
        }

        function showExportProgress(format) {
            const exportControls = document.querySelector('.correlation-export-controls');
            if (exportControls) {
                // Disable export buttons
                const buttons = exportControls.querySelectorAll('.correlation-export-btn');
                buttons.forEach(btn => btn.disabled = true);
                
                // Add progress indicator
                const progressDiv = document.createElement('div');
                progressDiv.className = 'export-progress';
                progressDiv.innerHTML = `
                    <div class="export-spinner"></div>
                    Exporting ${format}...
                `;
                progressDiv.id = 'exportProgress';
                
                exportControls.appendChild(progressDiv);
            }
        }

        function hideExportProgress() {
            // Re-enable export buttons
            const buttons = document.querySelectorAll('.correlation-export-btn');
            buttons.forEach(btn => btn.disabled = false);
            
            // Remove progress indicator
            const progress = document.getElementById('exportProgress');
            if (progress) {
                progress.remove();
            }
        }

        function showExportSuccess(format, filename) {
            const exportControls = document.querySelector('.correlation-export-controls');
            if (exportControls) {
                const successDiv = document.createElement('div');
                successDiv.className = 'export-progress';
                successDiv.style.color = '#059669';
                successDiv.innerHTML = `✅ ${format} exported successfully: ${filename}`;
                successDiv.id = 'exportSuccess';
                
                exportControls.appendChild(successDiv);
                
                // Remove success message after 3 seconds
                setTimeout(() => {
                    const success = document.getElementById('exportSuccess');
                    if (success) {
                        success.remove();
                    }
                }, 3000);
            }
        }

        function createDistributionChart(index, column) {
            const ctx = document.getElementById(`distChart${index}`);
            if (!ctx) return;

            const values = csvData.map(row => parseFloat(row[column])).filter(v => !isNaN(v));
            
            // Create histogram data
            const min = Math.min(...values);
            const max = Math.max(...values);
            const binCount = Math.min(10, Math.ceil(Math.sqrt(values.length)));
            const binSize = (max - min) / binCount;
            
            const bins = Array(binCount).fill(0);
            const labels = [];
            
            for (let i = 0; i < binCount; i++) {
                const binStart = min + i * binSize;
                const binEnd = min + (i + 1) * binSize;
                labels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
                
                values.forEach(value => {
                    if (value >= binStart && value < binEnd) {
                        bins[i]++;
                    }
                });
            }

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Frequency`,
                        data: bins,
                        backgroundColor: 'rgba(79, 70, 229, 0.8)',
                        borderColor: 'rgba(79, 70, 229, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: column
                            }
                        }
                    }
                }
            });
        }

        let currentSearchTerm = '';
        let currentRowsToShow = 25;
        let currentSelectedColumn = 'all';
        let searchTimeout = null;


        function updateTableRows(rowsToShow) {
            currentRowsToShow = rowsToShow === 'all' ? 'all' : parseInt(rowsToShow);
            const previewTab = document.getElementById('preview');
            previewTab.innerHTML = generateDataTable(currentRowsToShow, currentSearchTerm, currentSelectedColumn);
        }

        function handleSearch(searchTerm) {
            currentSearchTerm = searchTerm;
            
            // Clear existing timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Debounce the search to avoid too frequent updates
            searchTimeout = setTimeout(() => {
                const previewTab = document.getElementById('preview');
                previewTab.innerHTML = generateDataTable(currentRowsToShow, searchTerm, currentSelectedColumn);
            }, 1000); // 1 second delay
        }

        function handleColumnChange(selectedColumn) {
            currentSelectedColumn = selectedColumn;
            
            // Update the search input placeholder
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.placeholder = selectedColumn === 'all' ? 
                    'Type to search across all columns...' : 
                    `Type to search in ${selectedColumn}...`;
            }
            
            // Re-run search with new column selection
            const previewTab = document.getElementById('preview');
            previewTab.innerHTML = generateDataTable(currentRowsToShow, currentSearchTerm, selectedColumn);
        }

        function clearSearch() {
            currentSearchTerm = '';
            const previewTab = document.getElementById('preview');
            previewTab.innerHTML = generateDataTable(currentRowsToShow, '', currentSelectedColumn);
        }



        function highlightSearchTerm(text, searchTerm) {
            if (!searchTerm.trim()) return text;
            
            const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark style="background-color: #fef08a; padding: 0.1rem 0.2rem; border-radius: 0.25rem;">$1</mark>');
        }



        function inferDataType(columnName) {
            const values = csvData.map(row => row[columnName]).filter(v => v !== '' && v !== null && v !== undefined);
            
            if (values.length === 0) return 'unknown';
            

            
            // Check if it's a date
            const datePatterns = [
                /^\d{4}-\d{2}-\d{2}$/, // YYYY-MM-DD
                /^\d{2}\/\d{2}\/\d{4}$/, // MM/DD/YYYY
                /^\d{2}-\d{2}-\d{4}$/, // MM-DD-YYYY
                /^\d{4}\/\d{2}\/\d{2}$/, // YYYY/MM/DD
                /^\d{1,2}\/\d{1,2}\/\d{2,4}$/, // M/D/YY or M/D/YYYY
                /^\d{1,2}-\d{1,2}-\d{2,4}$/, // M-D-YY or M-D-YYYY
                /^\d{1,2}\.\d{1,2}\.\d{2,4}$/, // M.D.YY or M.D.YYYY
                /^[A-Za-z]{3}\s\d{1,2},?\s\d{4}$/, // Jan 1, 2020 or Jan 1 2020
                /^\d{1,2}\s[A-Za-z]{3}\s\d{4}$/, // 1 Jan 2020
                /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, // ISO datetime
                /^\d{2}:\d{2}:\d{2}$/, // Time only
                /^\d{2}:\d{2}$/ // Time only (HH:MM)
            ];
            
            const dateMatches = values.filter(value => 
                datePatterns.some(pattern => pattern.test(value.toString()))
            );
            
            if (dateMatches.length > values.length * 0.7) {
                return 'date';
            }
            
            // Check if it's numeric
            const numericValues = values.filter(value => {
                const num = parseFloat(value);
                return !isNaN(num) && isFinite(num);
            });
            
            if (numericValues.length > values.length * 0.8) {
                // Check if it's integer or float
                const integers = numericValues.filter(value => {
                    const num = parseFloat(value);
                    return Number.isInteger(num);
                });
                
                if (integers.length > numericValues.length * 0.9) {
                    return 'integer';
                } else {
                    return 'number';
                }
            }
            
            // Check if it's boolean
            const booleanValues = values.filter(value => {
                const str = value.toString().toLowerCase();
                return str === 'true' || str === 'false' || str === '1' || str === '0' || str === 'yes' || str === 'no';
            });
            
            if (booleanValues.length > values.length * 0.8) {
                return 'boolean';
            }
            
            // Check if it's email
            const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            const emailMatches = values.filter(value => emailPattern.test(value.toString()));
            
            if (emailMatches.length > values.length * 0.7) {
                return 'email';
            }
            
            // Check if it's URL
            const urlPattern = /^https?:\/\/.+/;
            const urlMatches = values.filter(value => urlPattern.test(value.toString()));
            
            if (urlMatches.length > values.length * 0.7) {
                return 'url';
            }
            
            // Check if it's currency
            const currencyPattern = /^[\$€£¥₹]?\s*\d+([.,]\d{3})*([.,]\d{2})?$/;
            const currencyMatches = values.filter(value => currencyPattern.test(value.toString()));
            
            if (currencyMatches.length > values.length * 0.7) {
                return 'currency';
            }
            
            // Check if it's percentage
            const percentagePattern = /^\d+\.?\d*%$/;
            const percentageMatches = values.filter(value => percentagePattern.test(value.toString()));
            
            if (percentageMatches.length > values.length * 0.7) {
                return 'percentage';
            }
            
            // Default to string
            return 'string';
        }

        function updateSummaryStats() {
            const variableSelect = document.getElementById('variableSelect');
            if (!variableSelect) return;
            
            // Get all selected variables
            const selectedVariables = Array.from(variableSelect.selectedOptions).map(option => option.value);
            
            if (selectedVariables.length === 0) {
                const statsResults = document.getElementById('statsResults');
                if (statsResults) {
                    statsResults.innerHTML = `
                        <div class="no-stats">
                            <p>Please select at least one variable to display statistics</p>
                        </div>
                    `;
                }
                return;
            }

            const statsResults = document.getElementById('statsResults');
            if (statsResults) {
                statsResults.innerHTML = generateMultiVariableStatsResults(selectedVariables);
            }
        }

        function generateStatsResults(variable, selectedStats) {
            const variableType = getEffectiveVariableType(variable);
            
            if (shouldIgnoreColumn(variableType)) {
                return `<div class="stat-card"><h4>${variable}</h4><p>Column ignored (Null type)</p></div>`;
            }
            
            if (isNumericType(variableType)) {
                return generateNumericStats(variable, selectedStats);
            } else {
                return generateCategoricalStats(variable, selectedStats);
            }
        }

        function generateMultiVariableStatsResults(variables) {
            if (variables.length === 0) {
                return `
                    <div class="no-stats">
                        <p>Please select at least one variable to display statistics</p>
                    </div>
                `;
            }

            return `
                <div class="multi-variable-stats">
                    ${variables.map(variable => {
                        const variableType = getEffectiveVariableType(variable);
                        if (shouldIgnoreColumn(variableType)) {
                            return `<div class="stat-card"><h4>${variable}</h4><p>Column ignored (Null type)</p></div>`;
                        }
                        const statsHTML = isNumericType(variableType) 
                            ? generateAllNumericStats(variable)
                            : generateAllCategoricalStats(variable);
                        
                        return `
                            <div class="variable-stats-group">
                                <h4 class="variable-title">${variable}</h4>
                                <div class="variable-type-badge ${variableType}">${variableType}</div>
                                ${statsHTML}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function generateNumericStats(variable, selectedStats) {
            const values = csvData.map(row => parseFloat(row[variable])).filter(v => !isNaN(v));
            
            if (values.length === 0) {
                return `
                    <div class="no-stats">
                        <p>No valid numeric data found for ${variable}</p>
                    </div>
                `;
            }

            const stats = calculateNumericStatistics(values);
            const filteredStats = selectedStats.map(stat => ({
                key: stat,
                value: stats[stat],
                label: getNumericStatLabel(stat)
            }));

            if (filteredStats.length === 0) {
                return `
                    <div class="no-stats">
                        <p>Please select at least one statistic to display</p>
                    </div>
                `;
            }

            return `
                <div class="stats-grid">
                    ${filteredStats.map(stat => `
                        <div class="stat-card">
                            <div class="stat-number">${stat.value}</div>
                            <div class="stat-label">${stat.label}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function generateAllNumericStats(variable) {
            const values = csvData.map(row => parseFloat(row[variable])).filter(v => !isNaN(v));
            
            if (values.length === 0) {
                return `
                    <div class="no-stats">
                        <p>No valid numeric data found for ${variable}</p>
                    </div>
                `;
            }

            const stats = calculateNumericStatistics(values);
            const allStats = [
                { key: 'count', value: stats.count, label: 'Count' },
                { key: 'mean', value: stats.mean, label: 'Mean' },
                { key: 'median', value: stats.median, label: 'Median' },
                { key: 'std', value: stats.std, label: 'Standard Deviation' },
                { key: 'min', value: stats.min, label: 'Minimum' },
                { key: 'max', value: stats.max, label: 'Maximum' },
                { key: 'q25', value: stats.q25, label: '25th Percentile' },
                { key: 'q75', value: stats.q75, label: '75th Percentile' }
            ];

            return `
                <div class="stats-grid">
                    ${allStats.map(stat => `
                        <div class="stat-card">
                            <div class="stat-number">${stat.value}</div>
                            <div class="stat-label">${stat.label}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function generateCategoricalStats(variable, selectedStats) {
            const values = csvData.map(row => row[variable]).filter(v => v !== '' && v !== null && v !== undefined);
            
            if (values.length === 0) {
                return `
                    <div class="no-stats">
                        <p>No valid categorical data found for ${variable}</p>
                    </div>
                `;
            }

            const stats = calculateCategoricalStatistics(values);
            const filteredStats = selectedStats.map(stat => ({
                key: stat,
                value: stats[stat],
                label: getCategoricalStatLabel(stat)
            }));

            if (filteredStats.length === 0) {
                return `
                    <div class="no-stats">
                        <p>Please select at least one statistic to display</p>
                    </div>
                `;
            }

            return `
                <div class="stats-grid">
                    ${filteredStats.map(stat => `
                        <div class="stat-card">
                            <div class="stat-number">${stat.value}</div>
                            <div class="stat-label">${stat.label}</div>
                        </div>
                    `).join('')}
                </div>
                <div class="categorical-details">
                    <h4>Top Categories</h4>
                    <div class="category-list">
                        ${stats.topCategories.map(cat => `
                            <div class="category-item">
                                <span class="category-name">${cat.value}</span>
                                <span class="category-count">${cat.count} (${cat.percentage}%)</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function generateAllCategoricalStats(variable) {
            const values = csvData.map(row => row[variable]).filter(v => v !== '' && v !== null && v !== undefined);
            
            if (values.length === 0) {
                return `
                    <div class="no-stats">
                        <p>No valid categorical data found for ${variable}</p>
                    </div>
                `;
            }

            const stats = calculateCategoricalStatistics(values);
            const allStats = [
                { key: 'count', value: stats.count, label: 'Count' },
                { key: 'unique', value: stats.unique, label: 'Unique Values' },
                { key: 'mode', value: stats.mode, label: 'Mode (Most Common)' },
                { key: 'modeCount', value: stats.modeCount, label: 'Mode Count' },
                { key: 'modePercentage', value: stats.modePercentage, label: 'Mode Percentage' }
            ];

            return `
                <div class="stats-grid">
                    ${allStats.map(stat => `
                        <div class="stat-card">
                            <div class="stat-number">${stat.value}</div>
                            <div class="stat-label">${stat.label}</div>
                        </div>
                    `).join('')}
                </div>
                <div class="categorical-details">
                    <h4>Top Categories</h4>
                    <div class="category-list">
                        ${stats.topCategories.map(cat => `
                            <div class="category-item">
                                <span class="category-name">${cat.value}</span>
                                <span class="category-count">${cat.count} (${cat.percentage}%)</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function getVariableType(variable) {
            const numericValues = csvData.map(row => parseFloat(row[variable])).filter(v => !isNaN(v));
            const totalValues = csvData.map(row => row[variable]).filter(v => v !== '' && v !== null && v !== undefined);
            const uniqueValues = [...new Set(totalValues)];
            
            // Check for Boolean values first
            const booleanKeywords = ['survived', 'dead', 'alive', 'active', 'inactive', 'enabled', 'disabled', 'true', 'false'];
            const columnNameLower = variable.toLowerCase();
            const hasBooleanKeyword = booleanKeywords.some(keyword => columnNameLower.includes(keyword));
            
            // Check if values look like boolean (only 0/1, true/false, yes/no, etc.)
            const normalizedValues = totalValues.map(v => v.toString().toLowerCase().trim());
            const booleanPatterns = [
                ['0', '1'],
                ['true', 'false'],
                ['yes', 'no'],
                ['y', 'n'],
                ['dead', 'alive'],
                ['survived', 'died']
            ];
            
            const isBooleanLike = booleanPatterns.some(pattern => {
                const hasOnlyPatternValues = normalizedValues.every(v => pattern.includes(v));
                const hasAllPatternValues = pattern.every(p => normalizedValues.includes(p));
                return hasOnlyPatternValues && uniqueValues.length <= 2;
            });
            
            if (hasBooleanKeyword || isBooleanLike) {
                return 'boolean';
            }
            
            // Special case: if column name suggests categorical (like class, category, type, etc.)
            const categoricalKeywords = ['class', 'category', 'type', 'group', 'level', 'grade', 'status', 'sex', 'gender'];
            const hasCategoricalKeyword = categoricalKeywords.some(keyword => columnNameLower.includes(keyword));
            
            // If has categorical keyword or has few unique values (like 1,2,3 for classes), treat as categorical
            if (hasCategoricalKeyword || (uniqueValues.length <= 10 && uniqueValues.length < totalValues.length * 0.1)) {
                return 'categorical';
            }
            
            // If more than 80% of values are numeric and has many unique values, consider it numeric
            return (numericValues.length / totalValues.length) > 0.8 && uniqueValues.length > 10 ? 'numeric' : 'categorical';
        }

        function getDefaultStats(variableType) {
            if (variableType === 'numeric') {
                return ['count', 'mean', 'median', 'std', 'min', 'max', 'q25', 'q75'];
            } else {
                return ['count', 'unique', 'mode', 'modeCount', 'modePercentage'];
            }
        }

        function getAvailableStats(variableType) {
            if (variableType === 'numeric') {
                return ['count', 'mean', 'median', 'std', 'min', 'max', 'q25', 'q75'];
            } else {
                return ['count', 'unique', 'mode', 'modeCount', 'modePercentage'];
            }
        }



        function calculateNumericStatistics(values) {
            const sorted = values.sort((a, b) => a - b);
            const n = values.length;
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = sum / n;
            const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
            const std = Math.sqrt(variance);
            
            // Median
            const median = n % 2 === 0 
                ? (sorted[n/2 - 1] + sorted[n/2]) / 2 
                : sorted[Math.floor(n/2)];
            
            // Percentiles
            const q25 = sorted[Math.floor(n * 0.25)];
            const q75 = sorted[Math.floor(n * 0.75)];

            return {
                count: n,
                mean: mean.toFixed(2),
                median: median.toFixed(2),
                std: std.toFixed(2),
                min: sorted[0].toFixed(2),
                max: sorted[n-1].toFixed(2),
                q25: q25.toFixed(2),
                q75: q75.toFixed(2)
            };
        }

        function calculateCategoricalStatistics(values) {
            const n = values.length;
            const uniqueValues = [...new Set(values)];
            
            // Count frequency of each value
            const frequency = {};
            values.forEach(value => {
                frequency[value] = (frequency[value] || 0) + 1;
            });
            
            // Find mode (most common value)
            const mode = Object.keys(frequency).reduce((a, b) => frequency[a] > frequency[b] ? a : b);
            const modeCount = frequency[mode];
            const modePercentage = ((modeCount / n) * 100).toFixed(1);
            
            // Get top categories
            const topCategories = Object.entries(frequency)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .map(([value, count]) => ({
                    value: value,
                    count: count,
                    percentage: ((count / n) * 100).toFixed(1)
                }));

            return {
                count: n,
                unique: uniqueValues.length,
                mode: mode,
                modeCount: modeCount,
                modePercentage: modePercentage + '%',
                topCategories: topCategories
            };
        }

        function getNumericStatLabel(stat) {
            const labels = {
                count: 'Count',
                mean: 'Mean',
                median: 'Median',
                std: 'Std Dev',
                min: 'Minimum',
                max: 'Maximum',
                q25: '25th Percentile',
                q75: '75th Percentile'
            };
            return labels[stat] || stat;
        }

        function getCategoricalStatLabel(stat) {
            const labels = {
                count: 'Count',
                unique: 'Unique Values',
                mode: 'Mode',
                modeCount: 'Mode Count',
                modePercentage: 'Mode %'
            };
            return labels[stat] || stat;
        }

        function showNoData() {
            const tabsContainer = document.querySelector('.tabs-container');
            tabsContainer.innerHTML = `
                <div class="no-data">
                    <div class="no-data-icon">📊</div>
                    <h3>No Data Available</h3>
                    <p>Please upload a CSV file to see visualizations</p>
                    <button class="chart-btn" onclick="window.location.href='upload.html'">Upload Data</button>
                </div>
            `;
        }

        function goBack() {
            window.location.href = 'dashboard.html';
        }

        // Data type management functionality
        let columnTypeOverrides = {}; // Store user-defined column types

        function loadColumnTypeOverrides() {
            // Load saved column type overrides from localStorage
            const savedOverrides = localStorage.getItem('columnTypeOverrides');
            if (savedOverrides) {
                try {
                    columnTypeOverrides = JSON.parse(savedOverrides);
                    
                    // Clean up overrides for columns that no longer exist
                    cleanupColumnTypeOverrides();
                } catch (error) {
                    console.warn('Failed to load column type overrides:', error);
                    columnTypeOverrides = {};
                }
            }
        }

        function cleanupColumnTypeOverrides() {
            // Remove column type overrides for columns that no longer exist in the current dataset
            const validColumns = new Set(headers);
            const overrideColumns = Object.keys(columnTypeOverrides);
            let hasChanges = false;
            
            overrideColumns.forEach(column => {
                if (!validColumns.has(column)) {
                    delete columnTypeOverrides[column];
                    hasChanges = true;
                }
            });
            
            // Save if we made any cleanup changes
            if (hasChanges) {
                saveColumnTypeOverrides();
            }
        }

        function saveColumnTypeOverrides() {
            // Save column type overrides to localStorage
            try {
                localStorage.setItem('columnTypeOverrides', JSON.stringify(columnTypeOverrides));
            } catch (error) {
                console.warn('Failed to save column type overrides:', error);
            }
        }

        function getEffectiveVariableType(variable) {
            // Check if user has overridden the type
            if (columnTypeOverrides[variable]) {
                return columnTypeOverrides[variable];
            }
            // Fall back to automatic detection
            return getVariableType(variable);
        }

        function getTypeDisplayName(type) {
            const displayNames = {
                'numeric': 'Numeric',
                'categorical': 'Categorical',
                'integer': 'Integer',
                'float': 'Float / Number',
                'string': 'String / Text',
                'boolean': 'Boolean',
                'date': 'Date',
                'time': 'Time',
                'datetime': 'Datetime',
                'currency': 'Currency',
                'percent': 'Percent',
                'null': 'Null / Ignore'
            };
            return displayNames[type] || type.charAt(0).toUpperCase() + type.slice(1);
        }

        function getTypeCategory(type) {
            // Map specific types to general categories for CSS styling and analysis
            const numericTypes = ['numeric', 'integer', 'float', 'currency', 'percent'];
            const textTypes = ['categorical', 'string'];
            const dateTypes = ['date', 'time', 'datetime'];
            const booleanTypes = ['boolean'];
            const nullTypes = ['null'];
            
            if (numericTypes.includes(type)) return 'numeric';
            if (textTypes.includes(type)) return 'categorical';
            if (dateTypes.includes(type)) return 'date';
            if (booleanTypes.includes(type)) return 'boolean';
            if (nullTypes.includes(type)) return 'null';
            
            return 'categorical'; // Default fallback
        }

        function isNumericType(type) {
            return ['numeric', 'integer', 'float', 'currency', 'percent', 'boolean'].includes(type);
        }

        function isCategoricalType(type) {
            return ['categorical', 'string', 'boolean'].includes(type);
        }

        function isDateType(type) {
            return ['date', 'time', 'datetime'].includes(type);
        }

        function isTemporalType(type) {
            return ['date', 'time', 'datetime'].includes(type);
        }

        function shouldIgnoreColumn(type) {
            return type === 'null';
        }

        // Temporal data detection functions
        function detectTemporalPattern(values) {
            if (!values || values.length === 0) return null;
            
            // Sample a reasonable number of values for pattern detection
            const sampleSize = Math.min(20, values.length);
            const sampleValues = values.slice(0, sampleSize).filter(v => v && v.toString().trim() !== '');
            
            if (sampleValues.length === 0) return null;
            
            // Date patterns to detect
            const patterns = {
                'date': [
                    /^\d{4}-\d{1,2}-\d{1,2}$/,           // YYYY-MM-DD, YYYY-M-D
                    /^\d{1,2}\/\d{1,2}\/\d{4}$/,        // MM/DD/YYYY, M/D/YYYY
                    /^\d{1,2}-\d{1,2}-\d{4}$/,          // MM-DD-YYYY, M-D-YYYY
                    /^\d{4}\/\d{1,2}\/\d{1,2}$/,        // YYYY/MM/DD, YYYY/M/D
                    /^\d{1,2}\.\d{1,2}\.\d{4}$/,        // DD.MM.YYYY, D.M.YYYY
                    /^[A-Za-z]{3}\s+\d{1,2},?\s+\d{4}$/, // Jan 1, 2020 or Jan 1 2020
                    /^\d{1,2}\s+[A-Za-z]{3}\s+\d{4}$/,  // 1 Jan 2020
                ],
                'time': [
                    /^\d{1,2}:\d{2}(:\d{2})?(\s*(AM|PM))?$/i, // HH:MM, HH:MM:SS, with optional AM/PM
                    /^\d{1,2}:\d{2}(:\d{2})?$/,              // 24-hour format
                ],
                'datetime': [
                    /^\d{4}-\d{1,2}-\d{1,2}\s+\d{1,2}:\d{2}(:\d{2})?/,     // YYYY-MM-DD HH:MM:SS
                    /^\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}(:\d{2})?/,   // MM/DD/YYYY HH:MM:SS
                    /^\d{4}-\d{1,2}-\d{1,2}T\d{1,2}:\d{2}(:\d{2})?/,       // ISO format YYYY-MM-DDTHH:MM:SS
                    /^[A-Za-z]{3}\s+\d{1,2},?\s+\d{4}\s+\d{1,2}:\d{2}/,    // Jan 1, 2020 10:30
                ]
            };
            
            // Check what percentage of values match each pattern type
            const patternMatches = {};
            for (const [type, typePatterns] of Object.entries(patterns)) {
                let matches = 0;
                for (const value of sampleValues) {
                    const strValue = value.toString().trim();
                    if (typePatterns.some(pattern => pattern.test(strValue))) {
                        matches++;
                    }
                }
                patternMatches[type] = matches / sampleValues.length;
            }
            
            // Return the pattern type with highest match percentage (must be >= 80%)
            const threshold = 0.8;
            const bestMatch = Object.entries(patternMatches)
                .filter(([_, percentage]) => percentage >= threshold)
                .sort(([_, a], [__, b]) => b - a)[0];
            
            return bestMatch ? {
                type: bestMatch[0],
                confidence: bestMatch[1],
                sampleValues: sampleValues.slice(0, 3)
            } : null;
        }

        function isTextColumnTemporal(columnName) {
            // Check if a text column appears to contain temporal data
            const values = csvData.map(row => row[columnName]).filter(v => v !== '' && v !== null && v !== undefined);
            const temporalPattern = detectTemporalPattern(values);
            return temporalPattern;
        }

        function parseTemporalValue(value, temporalType) {
            if (!value || value.toString().trim() === '') return null;
            
            const strValue = value.toString().trim();
            let date = null;
            
            try {
                switch (temporalType) {
                    case 'date':
                        date = new Date(strValue);
                        break;
                    case 'time':
                        // For time-only values, use today's date as base
                        const today = new Date().toISOString().split('T')[0];
                        date = new Date(`${today}T${strValue}`);
                        break;
                    case 'datetime':
                        date = new Date(strValue);
                        break;
                    default:
                        date = new Date(strValue);
                }
                
                // Check if the parsed date is valid
                return isNaN(date.getTime()) ? null : date;
            } catch (error) {
                return null;
            }
        }

        function formatTemporalLabel(date, temporalType) {
            if (!date || isNaN(date.getTime())) return '';
            
            try {
                switch (temporalType) {
                    case 'date':
                        return date.toISOString().split('T')[0]; // YYYY-MM-DD
                    case 'time':
                        return date.toTimeString().split(' ')[0].substring(0, 5); // HH:MM
                    case 'datetime':
                        return date.toISOString().replace('T', ' ').substring(0, 19); // YYYY-MM-DD HH:MM:SS
                    default:
                        return date.toISOString().split('T')[0];
                }
            } catch (error) {
                return date.toString();
            }
        }

        function generateDataTypesContent() {
            const allColumns = headers;
            
            if (allColumns.length === 0) {
                return `
                    <div class="datatypes-container">
                        <div class="no-data">
                            <div class="no-data-icon">📊</div>
                            <h3>No Data Available</h3>
                            <p>No columns found for data type configuration.</p>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="datatypes-container">
                    <h3 class="datatypes-title">Data Type Configuration</h3>
                    <p class="datatypes-description">
                        Review and modify the data types for each column. The system automatically detects types, but you can override them if needed.
                        Changing a column's type will affect how it appears in statistics, visualizations, and analysis.
                        <strong>Your type settings are automatically saved and will persist when you refresh the page.</strong>
                    </p>
                    
                    <div class="column-type-grid">
                        ${allColumns.map(column => generateColumnTypeCard(column)).join('')}
                    </div>
                    
                    <div class="apply-all-section">
                        <h4 class="apply-all-title">Bulk Actions</h4>
                        <div class="apply-all-controls">
                            <button class="apply-all-btn" onclick="resetAllColumnTypes()">Reset All to Auto-Detect</button>
                            <button class="apply-all-btn" onclick="refreshAllTabs()">Apply Changes & Refresh</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateColumnTypeCard(column) {
            const currentType = getEffectiveVariableType(column);
            const autoDetectedType = getVariableType(column);
            const isOverridden = columnTypeOverrides[column] !== undefined;
            
            // Get sample values for preview
            const sampleValues = csvData.slice(0, 5).map(row => row[column]).filter(v => v !== '' && v !== null && v !== undefined);
            const previewText = sampleValues.length > 0 ? sampleValues.join(', ') : 'No data';
            
            // Get display name for current type
            const currentTypeDisplay = getTypeDisplayName(currentType);
            
            return `
                <div class="column-type-card">
                    <div class="column-type-header">
                        <div class="column-name">${column}</div>
                        <div class="current-type-badge type-${getTypeCategory(currentType)}">
                            ${currentTypeDisplay}
                            ${isOverridden ? ' (Override)' : ' (Auto)'}
                        </div>
                    </div>
                    
                    <div class="type-controls">
                        <select class="type-selector" id="type-${column}" onchange="updateColumnTypeButton('${column}')">
                            <option value="auto" ${!isOverridden ? 'selected' : ''}>Auto-detect (${getTypeDisplayName(autoDetectedType)})</option>
                            <optgroup label="Numeric Types">
                                <option value="integer" ${columnTypeOverrides[column] === 'integer' ? 'selected' : ''}>Integer</option>
                                <option value="float" ${columnTypeOverrides[column] === 'float' ? 'selected' : ''}>Float / Number</option>
                                <option value="currency" ${columnTypeOverrides[column] === 'currency' ? 'selected' : ''}>Currency</option>
                                <option value="percent" ${columnTypeOverrides[column] === 'percent' ? 'selected' : ''}>Percent</option>
                            </optgroup>
                            <optgroup label="Text Types">
                                <option value="string" ${columnTypeOverrides[column] === 'string' ? 'selected' : ''}>String / Text</option>
                                <option value="categorical" ${columnTypeOverrides[column] === 'categorical' ? 'selected' : ''}>Categorical</option>
                            </optgroup>
                            <optgroup label="Date/Time Types">
                                <option value="date" ${columnTypeOverrides[column] === 'date' ? 'selected' : ''}>Date</option>
                                <option value="time" ${columnTypeOverrides[column] === 'time' ? 'selected' : ''}>Time</option>
                                <option value="datetime" ${columnTypeOverrides[column] === 'datetime' ? 'selected' : ''}>Datetime</option>
                            </optgroup>
                            <optgroup label="Other Types">
                                <option value="boolean" ${columnTypeOverrides[column] === 'boolean' ? 'selected' : ''}>Boolean</option>
                                <option value="null" ${columnTypeOverrides[column] === 'null' ? 'selected' : ''}>Null / Ignore</option>
                            </optgroup>
                        </select>
                        <button class="apply-type-btn" id="apply-${column}" onclick="applyColumnType('${column}')" disabled>
                            Apply
                        </button>
                    </div>
                    
                    <div class="column-preview">
                        <div class="preview-label">Sample values:</div>
                        <div class="preview-values">${previewText}</div>
                    </div>
                </div>
            `;
        }

        function updateColumnTypeButton(column) {
            const selector = document.getElementById(`type-${column}`);
            const button = document.getElementById(`apply-${column}`);
            const currentValue = selector.value;
            const currentType = getEffectiveVariableType(column);
            
            // Enable button if value has changed
            const hasChanged = (currentValue === 'auto' && columnTypeOverrides[column] !== undefined) ||
                              (currentValue !== 'auto' && currentValue !== currentType);
            
            button.disabled = !hasChanged;
        }

        function applyColumnType(column) {
            const selector = document.getElementById(`type-${column}`);
            const newValue = selector.value;
            
            if (newValue === 'auto') {
                // Remove override to use auto-detection
                delete columnTypeOverrides[column];
            } else {
                // Set override
                columnTypeOverrides[column] = newValue;
            }
            
            // Save to localStorage
            saveColumnTypeOverrides();
            
            // Refresh the data types tab to show updated state
            generateDataTypesTab();
            
            // Also refresh the preview tab to show updated types
            generatePreviewTab();
            
            // Show success message
            showTypeChangeNotification(column, newValue);
        }

        function resetAllColumnTypes() {
            if (confirm('Are you sure you want to reset all column types to auto-detection? This will remove all manual overrides.')) {
                columnTypeOverrides = {};
                
                // Save to localStorage
                saveColumnTypeOverrides();
                
                generateDataTypesTab();
                generatePreviewTab();
                showTypeChangeNotification('all columns', 'auto-detect');
            }
        }

        function refreshAllTabs() {
            // Regenerate all tabs that depend on column types
            generatePreviewTab();
            generateSummaryTab();
            generatePlotsTab();
            generateCorrelationTab();
            
            // Show success message
            showTypeChangeNotification('all tabs', 'refreshed');
        }

        function showTypeChangeNotification(column, type) {
            // Simple notification - could be enhanced with a toast system
            const typeDisplay = type === 'auto' ? 'auto-detect' : getTypeDisplayName(type);
            const message = column === 'all tabs' ? 
                `${column} have been ${type}` : 
                `Column "${column}" type changed to ${typeDisplay}`;
            
            // Temporarily show notification in the tab title
            const titleElement = document.querySelector('.datatypes-title');
            if (titleElement) {
                const originalTitle = titleElement.textContent;
                titleElement.textContent = `✓ ${message}`;
                
                setTimeout(() => {
                    if (document.querySelector('.datatypes-title')) {
                        document.querySelector('.datatypes-title').textContent = originalTitle;
                    }
                }, 3000);
            }
        }

        // Override the original getVariableType function calls to use the effective type
        function getEffectiveVariableTypeForAnalysis(variable) {
            return getEffectiveVariableType(variable);
        }

        // Bar chart aggregation functionality
        function getSelectedAggregationMethod() {
            const aggregationSelect = document.getElementById('aggregationMethod');
            return aggregationSelect ? aggregationSelect.value : 'mean';
        }

        function applyAggregation(values, method) {
            if (!values || values.length === 0) return 0;
            
            switch (method) {
                case 'mean':
                    return values.reduce((sum, val) => sum + val, 0) / values.length;
                case 'median':
                    const sorted = [...values].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 === 0 
                        ? (sorted[mid - 1] + sorted[mid]) / 2 
                        : sorted[mid];
                case 'sum':
                    return values.reduce((sum, val) => sum + val, 0);
                case 'count':
                    return values.length;
                case 'min':
                    return Math.min(...values);
                case 'max':
                    return Math.max(...values);
                default:
                    return values.reduce((sum, val) => sum + val, 0) / values.length;
            }
        }

        function getAggregationDisplayName(method) {
            const displayNames = {
                'mean': 'Mean',
                'median': 'Median',
                'sum': 'Sum',
                'count': 'Count',
                'min': 'Minimum',
                'max': 'Maximum'
            };
            return displayNames[method] || 'Mean';
        }

        function updateBarChartAggregation() {
            // Regenerate the current plot when aggregation method changes
            if (window.currentPlotConfig && window.currentPlotConfig.plotType === 'bar') {
                generatePlot(
                    window.currentPlotConfig.plotType,
                    window.currentPlotConfig.xAxis,
                    window.currentPlotConfig.yAxis
                );
            }
        }

        function showTopCategories(xAxisColumn) {
            // Get frequency count of each category
            const categoryFrequency = {};
            csvData.forEach(row => {
                const category = row[xAxisColumn];
                if (category !== '' && category !== null && category !== undefined) {
                    categoryFrequency[category] = (categoryFrequency[category] || 0) + 1;
                }
            });

            // Sort by frequency and get top 20
            const sortedCategories = Object.entries(categoryFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(entry => entry[0]);

            // Store original data and filter to top categories
            if (!window.originalCsvData) {
                window.originalCsvData = [...csvData];
            }
            
            csvData = window.originalCsvData.filter(row => 
                sortedCategories.includes(row[xAxisColumn])
            );

            // Show success message and regenerate chart
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">✅</div>
                        <h4>Filtered to Top 20 Categories</h4>
                        <p>Showing data for the 20 most frequent categories in ${xAxisColumn}</p>
                        <p><strong>Categories:</strong> ${sortedCategories.slice(0, 5).join(', ')}${sortedCategories.length > 5 ? '...' : ''}</p>
                        <button class="generate-plot-btn" onclick="restoreOriginalData()">🔄 Restore All Data</button>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
            }

            // Generate the filtered chart
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');
            
            if (plotTypeSelect && xAxisSelect && yAxisSelect) {
                generatePlot(plotTypeSelect.value, xAxisSelect.value, yAxisSelect.value);
            }
        }

        function suggestAlternativePlot(xAxisColumn) {
            const xAxisType = getEffectiveVariableType(xAxisColumn);
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            
            let suggestedPlotType = '';
            let explanation = '';

            if (xAxisType === 'numeric') {
                suggestedPlotType = 'histogram';
                explanation = 'Histogram is perfect for showing the distribution of numeric values';
            } else if (xAxisType === 'date' || xAxisColumn.toLowerCase().includes('date') || xAxisColumn.toLowerCase().includes('time')) {
                suggestedPlotType = 'line';
                explanation = 'Line chart is ideal for showing trends over time';
            } else {
                suggestedPlotType = 'histogram';
                explanation = 'Histogram can help visualize the frequency distribution of categories';
            }

            // Update the plot type selector
            if (plotTypeSelect) {
                plotTypeSelect.value = suggestedPlotType;
                updatePlotConfiguration();
                
                // Show success message
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    setTimeout(() => {
                        const previewContent = plotPreview.querySelector('.preview-placeholder, .preview-ready, .preview-error');
                        if (previewContent) {
                            previewContent.innerHTML = `
                                <div class="preview-icon">💡</div>
                                <h4>Switched to ${suggestedPlotType.charAt(0).toUpperCase() + suggestedPlotType.slice(1)}</h4>
                                <p>${explanation}</p>
                                <p>Configure the axes below to generate your chart.</p>
                            `;
                        }
                    }, 100);
                }
            }
        }

        function restoreOriginalData() {
            if (window.originalCsvData) {
                csvData = [...window.originalCsvData];
                window.originalCsvData = null;
                
                // Regenerate the current plot with full data
                updateAxisPreview();
            }
        }

        function suggestAlternativePlotForAxis(currentPlotType, xAxis, yAxis) {
            const xAxisType = getEffectiveVariableType(xAxis);
            const yAxisType = getEffectiveVariableType(yAxis);
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            
            let suggestedPlotType = '';
            let explanation = '';

            // Suggest based on the invalid axis configuration
            if (currentPlotType === 'line') {
                if (xAxisType === 'categorical' && (yAxisType === 'numeric' || yAxisType === 'boolean')) {
                    suggestedPlotType = 'bar';
                    explanation = 'Bar chart is perfect for showing numeric values across categories';
                } else if (xAxisType === 'categorical' && yAxisType === 'categorical') {
                    suggestedPlotType = 'bar';
                    explanation = 'Bar chart with Count Y-axis can show the distribution of categories';
                } else {
                    suggestedPlotType = 'bar';
                    explanation = 'Bar chart is a good alternative for this data combination';
                }
            } else if (currentPlotType === 'scatter') {
                if (xAxisType === 'categorical' || yAxisType === 'categorical') {
                    suggestedPlotType = 'bar';
                    explanation = 'Bar chart works better when one axis is categorical';
                }
            }

            // Update the plot type selector
            if (plotTypeSelect && suggestedPlotType) {
                plotTypeSelect.value = suggestedPlotType;
                updatePlotConfiguration();
                
                // Show success message
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    setTimeout(() => {
                        const previewContent = plotPreview.querySelector('.preview-placeholder, .preview-ready, .preview-error, .preview-axis-type-error');
                        if (previewContent) {
                            previewContent.innerHTML = `
                                <div class="preview-icon">💡</div>
                                <h4>Switched to ${suggestedPlotType.charAt(0).toUpperCase() + suggestedPlotType.slice(1)} Chart</h4>
                                <p>${explanation}</p>
                                <p>The chart should now work with your selected axes. Configure any additional settings below.</p>
                            `;
                            previewContent.className = 'preview-ready';
                        }
                    }, 100);
                }
            }
        }

        function goToDataTypesTab() {
            // Switch to the Data Types tab
            showTab('datatypes');
            
            // Highlight the tab briefly
            const dataTypesTab = document.querySelector('[onclick="showTab(\'datatypes\')"]');
            if (dataTypesTab) {
                const originalStyle = dataTypesTab.style.background;
                dataTypesTab.style.background = '#eff6ff';
                dataTypesTab.style.transition = 'background-color 0.3s ease';
                
                setTimeout(() => {
                    dataTypesTab.style.background = originalStyle;
                }, 2000);
            }
            
            // Show a helpful message
            const dataTypesContent = document.getElementById('datatypes');
            if (dataTypesContent) {
                const helpMessage = document.createElement('div');
                helpMessage.style.cssText = `
                    background: #dbeafe;
                    border: 1px solid #3b82f6;
                    border-radius: 0.5rem;
                    padding: 1rem;
                    margin-bottom: 1rem;
                    color: #1e40af;
                    font-size: 0.875rem;
                `;
                helpMessage.innerHTML = `
                    <strong>💡 Data Type Override Help:</strong><br>
                    Find the column that's causing issues and change its type to "Numeric" if it contains numbers (like 1, 2, 3 for classes or years).
                    Then return to the Plots tab to create your chart.
                `;
                
                // Insert at the beginning of the datatypes content
                dataTypesContent.insertBefore(helpMessage, dataTypesContent.firstChild);
                
                // Remove the help message after 10 seconds
                setTimeout(() => {
                    if (helpMessage.parentNode) {
                        helpMessage.remove();
                    }
                }, 10000);
            }
        }

        function treatAsCategorical(xAxis, yAxis) {
            // Switch to bar chart
            const plotTypeSelect = document.getElementById('plotTypeSelect');
            if (plotTypeSelect) {
                plotTypeSelect.value = 'bar';
                updatePlotConfiguration();
                
                // Show success message
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    setTimeout(() => {
                        const previewContent = plotPreview.querySelector('.preview-placeholder, .preview-ready, .preview-error, .preview-low-uniqueness-warning');
                        if (previewContent) {
                            previewContent.innerHTML = `
                                <div class="preview-icon">✅</div>
                                <h4>Switched to Bar Chart</h4>
                                <p>Treating <strong>${xAxis}</strong> as categorical data. This will show ${yAxis} values grouped by each ${xAxis} category.</p>
                                <p>Configure aggregation method below if needed.</p>
                            `;
                            previewContent.className = 'preview-ready';
                        }
                    }, 100);
                }
            }
        }

        function aggregateByXAxis(xAxis, yAxis) {
            // Create an aggregated dataset and force line chart
            window.forceAggregatedLineChart = {
                xAxis: xAxis,
                yAxis: yAxis,
                aggregationMethod: 'mean'
            };
            
            // Generate aggregated chart immediately
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">📈</div>
                        <h4>Aggregated Line Chart</h4>
                        <p>Showing <strong>mean ${yAxis}</strong> for each <strong>${xAxis}</strong> value</p>
                        <div class="aggregation-method-selector">
                            <label for="aggregationMethodLine">Aggregation Method:</label>
                            <select id="aggregationMethodLine" onchange="updateAggregatedLineChart()">
                                <option value="mean">Mean (Average)</option>
                                <option value="median">Median</option>
                                <option value="sum">Sum</option>
                                <option value="count">Count</option>
                                <option value="min">Minimum</option>
                                <option value="max">Maximum</option>
                            </select>
                        </div>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate the aggregated line chart
                generateAggregatedLineChart(xAxis, yAxis, 'mean');
            }
        }

        function showAnywayLineChart(xAxis, yAxis) {
            // Force show the line chart despite warning
            window.ignoreLowUniquenessWarning = true;
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">⚠️</div>
                        <h4>Line Chart (Warning Ignored)</h4>
                        <p>Showing line chart for <strong>${xAxis}</strong> vs <strong>${yAxis}</strong> despite low uniqueness warning.</p>
                        <p><em>Note: This may not provide meaningful insights due to limited X-axis variation.</em></p>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate the regular line chart
                generatePlot('line', xAxis, yAxis);
            }
        }

        function updateAggregatedLineChart() {
            const aggregationMethod = document.getElementById('aggregationMethodLine').value;
            if (window.forceAggregatedLineChart) {
                generateAggregatedLineChart(
                    window.forceAggregatedLineChart.xAxis,
                    window.forceAggregatedLineChart.yAxis,
                    aggregationMethod
                );
            }
        }

        function generateAggregatedLineChart(xAxis, yAxis, aggregationMethod) {
            // Group data by X-axis values and aggregate Y-axis values
            const groupedData = {};
            const xAxisType = getEffectiveVariableType(xAxis);
            
            csvData.forEach(row => {
                let xValue = row[xAxis];
                const yValue = parseFloat(row[yAxis]);
                
                // Handle both numeric and categorical X-axis
                if (isNumericType(xAxisType)) {
                    xValue = parseFloat(xValue);
                    if (isNaN(xValue) || isNaN(yValue)) return;
                } else {
                    // For categorical data, use string value directly
                    if (!xValue || xValue.trim() === '' || isNaN(yValue)) return;
                    xValue = xValue.toString().trim();
                }
                
                if (!groupedData[xValue]) {
                    groupedData[xValue] = [];
                }
                groupedData[xValue].push(yValue);
            });

            // Calculate aggregated values
            let aggregatedData;
            if (isNumericType(xAxisType)) {
                // For numeric X-axis, sort numerically
                aggregatedData = Object.keys(groupedData)
                    .map(xValue => ({
                        x: parseFloat(xValue),
                        y: applyAggregation(groupedData[xValue], aggregationMethod),
                        label: xValue.toString()
                    }))
                    .sort((a, b) => a.x - b.x);
            } else {
                // For categorical X-axis, sort alphabetically or by frequency
                aggregatedData = Object.keys(groupedData)
                    .map(xValue => ({
                        x: xValue,
                        y: applyAggregation(groupedData[xValue], aggregationMethod),
                        label: xValue.toString()
                    }))
                    .sort((a, b) => a.x.localeCompare(b.x));
            }

            // Create the chart
            const canvas = document.getElementById('dynamicPlot');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            
            window.currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: aggregatedData.map(point => point.label),
                    datasets: [{
                        label: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis}`,
                        data: aggregatedData.map(point => point.y),
                        borderColor: 'rgba(79, 70, 229, 1)',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        pointBackgroundColor: 'rgba(79, 70, 229, 1)',
                        pointBorderColor: 'rgba(255, 255, 255, 1)',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis} by ${xAxis}`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xAxis,
                                font: {
                                    weight: 'bold'
                                }
                            },
                            type: isNumericType(xAxisType) ? 'linear' : 'category'
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis}`,
                                font: {
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        }

        // Binning and aggregation functionality
        function binAndAggregateAuto(xAxis, yAxis) {
            // Calculate optimal bin width automatically
            const xValues = csvData.map(row => parseFloat(row[xAxis])).filter(v => !isNaN(v));
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const range = xMax - xMin;
            
            // Auto-calculate bin width to create approximately 10-15 bins
            let binWidth;
            if (range <= 100) {
                binWidth = Math.ceil(range / 10);
            } else if (range <= 1000) {
                binWidth = Math.ceil(range / 15);
            } else {
                binWidth = Math.ceil(range / 12);
            }
            
            // Round bin width to nice numbers
            if (binWidth < 10) {
                binWidth = Math.max(1, Math.round(binWidth));
            } else if (binWidth < 100) {
                binWidth = Math.ceil(binWidth / 5) * 5;
            } else {
                binWidth = Math.ceil(binWidth / 50) * 50;
            }
            
            // Determine aggregation method based on Y-axis type
            const yAxisType = getEffectiveVariableType(yAxis);
            const defaultAggregation = yAxisType === 'boolean' ? 'mean' : 'mean';
            
            generateBinnedLineChart(xAxis, yAxis, binWidth, defaultAggregation, true);
        }

        function customBinAndAggregate(xAxis, yAxis) {
            // Calculate data range for better defaults
            const xValues = csvData.map(row => parseFloat(row[xAxis])).filter(v => !isNaN(v));
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const range = xMax - xMin;
            const yAxisType = getEffectiveVariableType(yAxis);
            
            // Suggest good bin widths
            let suggestedBinWidths = [];
            if (range <= 100) {
                suggestedBinWidths = [1, 2, 5, 10, 20];
            } else if (range <= 1000) {
                suggestedBinWidths = [5, 10, 25, 50, 100];
            } else {
                suggestedBinWidths = [50, 100, 250, 500, 1000];
            }
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">⚙️</div>
                        <h4>Custom Binning Configuration</h4>
                        <p>Configure how to bin <strong>${xAxis}</strong> values and aggregate <strong>${yAxis}</strong></p>
                        
                        <div class="binning-controls">
                            <div class="binning-controls-grid">
                                <div class="binning-control-group">
                                    <label for="binWidth">Bin Width:</label>
                                    <select id="binWidth" onchange="updateBinningPreview()">
                                        ${suggestedBinWidths.map(width => `
                                            <option value="${width}">${width}</option>
                                        `).join('')}
                                        <option value="custom">Custom...</option>
                                    </select>
                                    <input type="number" id="customBinWidth" style="display: none;" 
                                           placeholder="Enter bin width" min="1" onchange="updateBinningPreview()">
                                </div>
                                
                                <div class="binning-control-group">
                                    <label for="binAggregation">Aggregation Method:</label>
                                    <select id="binAggregation" onchange="updateBinningPreview()">
                                        <option value="mean" ${yAxisType === 'boolean' ? 'selected' : ''}>
                                            ${yAxisType === 'boolean' ? 'Mean (Percentage)' : 'Mean (Average)'}
                                        </option>
                                        <option value="median">Median</option>
                                        <option value="sum">Sum</option>
                                        <option value="count">Count</option>
                                        <option value="min">Minimum</option>
                                        <option value="max">Maximum</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="binning-preview-info" id="binningPreviewInfo">
                                <strong>📊 Preview:</strong> Will create bins of width <span id="previewBinWidth">${suggestedBinWidths[0]}</span> 
                                from ${xMin.toFixed(1)} to ${xMax.toFixed(1)} → 
                                <span id="previewBinCount">${Math.ceil(range / suggestedBinWidths[0])}</span> bins
                            </div>
                            
                            <button class="range-btn" onclick="applyCustomBinning('${xAxis}', '${yAxis}')">
                                📈 Generate Binned Line Chart
                            </button>
                        </div>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Set up bin width selector behavior
                const binWidthSelect = document.getElementById('binWidth');
                const customBinWidthInput = document.getElementById('customBinWidth');
                
                binWidthSelect.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        customBinWidthInput.style.display = 'block';
                        customBinWidthInput.focus();
                    } else {
                        customBinWidthInput.style.display = 'none';
                    }
                });
                
                // Generate initial preview
                updateBinningPreview();
            }
        }

        function updateBinningPreview() {
            const binWidthSelect = document.getElementById('binWidth');
            const customBinWidthInput = document.getElementById('customBinWidth');
            const previewBinWidth = document.getElementById('previewBinWidth');
            const previewBinCount = document.getElementById('previewBinCount');
            
            if (!binWidthSelect || !previewBinWidth || !previewBinCount) return;
            
            let binWidth = binWidthSelect.value === 'custom' ? 
                parseFloat(customBinWidthInput.value) || 1 : 
                parseFloat(binWidthSelect.value);
            
            if (window.currentPlotConfig) {
                const xValues = csvData.map(row => parseFloat(row[window.currentPlotConfig.xAxis])).filter(v => !isNaN(v));
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                const range = xMax - xMin;
                const binCount = Math.ceil(range / binWidth);
                
                previewBinWidth.textContent = binWidth;
                previewBinCount.textContent = binCount;
                
                // Generate preview chart
                generateBinnedLineChart(
                    window.currentPlotConfig.xAxis, 
                    window.currentPlotConfig.yAxis, 
                    binWidth, 
                    document.getElementById('binAggregation').value,
                    false
                );
            }
        }

        function applyCustomBinning(xAxis, yAxis) {
            const binWidthSelect = document.getElementById('binWidth');
            const customBinWidthInput = document.getElementById('customBinWidth');
            const binAggregation = document.getElementById('binAggregation');
            
            const binWidth = binWidthSelect.value === 'custom' ? 
                parseFloat(customBinWidthInput.value) || 1 : 
                parseFloat(binWidthSelect.value);
            
            generateBinnedLineChart(xAxis, yAxis, binWidth, binAggregation.value, true);
        }

        function showAnywayRawValues(xAxis, yAxis) {
            // Force show the line chart despite binning warning
            window.ignoreBinningWarning = true;
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">⚠️</div>
                        <h4>Raw Values Line Chart (Warning Ignored)</h4>
                        <p>Showing line chart for <strong>${xAxis}</strong> vs <strong>${yAxis}</strong> with all individual values.</p>
                        <p><em>Note: This may be difficult to read due to high cardinality. Consider binning for better insights.</em></p>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate the regular line chart
                generatePlot('line', xAxis, yAxis);
            }
        }

        // Temporal conversion and override functions
        function convertToTemporal(xAxis, yAxis, temporalType) {
            // Override the column type to the detected temporal type
            columnTypeOverrides[xAxis] = temporalType;
            saveColumnTypeOverrides();
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">🕒</div>
                        <h4>Converted to ${temporalType.charAt(0).toUpperCase() + temporalType.slice(1)} Type</h4>
                        <p>Column <strong>"${xAxis}"</strong> is now treated as ${temporalType} data.</p>
                        <p>✅ Chronological sorting enabled<br>
                           ✅ Time-aware formatting applied<br>
                           ✅ Temporal aggregation available</p>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate the temporal line chart
                generateTemporalLineChart(xAxis, yAxis, temporalType);
            }
        }

        function plotAsTextWithWarning(xAxis, yAxis) {
            // Override temporal suggestion and plot as text
            window.ignoreTemporalSuggestion = true;
            window.temporalOverrideActive = true;
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">📊</div>
                        <h4>Plotting as Text (Override Active)</h4>
                        <p>Showing line chart for <strong>${xAxis}</strong> vs <strong>${yAxis}</strong> treating X-axis as text.</p>
                        <p>⚠️ <em>Not sorted as time — override active</em></p>
                        <button class="range-btn secondary" onclick="removeTemporalOverride('${xAxis}', '${yAxis}')" style="margin-top: 1rem;">
                            🔄 Re-enable Temporal Detection
                        </button>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate regular line chart treating as categorical/text
                generateTextLineChart(xAxis, yAxis);
            }
        }

        function removeTemporalOverride(xAxis, yAxis) {
            // Remove the temporal override
            window.ignoreTemporalSuggestion = false;
            window.temporalOverrideActive = false;
            
            // Refresh the axis preview to show temporal suggestion again
            updateAxisPreview();
        }

        function generateTemporalLineChart(xAxis, yAxis, temporalType) {
            // Parse and sort temporal data chronologically
            const validData = csvData
                .map((row, index) => {
                    const xValue = parseTemporalValue(row[xAxis], temporalType);
                    const yValue = parseFloat(row[yAxis]);
                    return {
                        x: xValue,
                        y: yValue,
                        originalIndex: index,
                        originalXValue: row[xAxis]
                    };
                })
                .filter(point => point.x !== null && !isNaN(point.y))
                .filter(point => !window.excludedPoints.has(point.originalIndex))
                .sort((a, b) => a.x.getTime() - b.x.getTime()); // Chronological sorting

            // Check for high cardinality and offer aggregation
            const uniqueXValues = new Set(validData.map(point => point.x.getTime())).size;
            if (uniqueXValues > 100 && !window.ignoreTemporalAggregation) {
                showTemporalAggregationOptions(xAxis, yAxis, temporalType, validData);
                return;
            }

            // Apply axis range filtering if ranges are set
            let displayData = validData;
            if (window.currentAxisRanges) {
                displayData = validData.filter(point => {
                    let includePoint = true;
                    
                    if (window.currentAxisRanges.x.min !== null && point.x.getTime() < new Date(window.currentAxisRanges.x.min).getTime()) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.x.max !== null && point.x.getTime() > new Date(window.currentAxisRanges.x.max).getTime()) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.y.min !== null && point.y < window.currentAxisRanges.y.min) {
                        includePoint = false;
                    }
                    if (window.currentAxisRanges.y.max !== null && point.y > window.currentAxisRanges.y.max) {
                        includePoint = false;
                    }
                    
                    return includePoint;
                });
            }

            // Limit data points if no custom ranges are set and we have too many points
            if (!window.currentAxisRanges && displayData.length > 500) {
                const step = Math.floor(displayData.length / 500);
                displayData = displayData.filter((_, index) => index % step === 0).slice(0, 500);
            }

            // Format labels according to temporal type
            const labels = displayData.map(point => formatTemporalLabel(point.x, temporalType));
            const data = displayData.map(point => point.y);

            const canvas = document.getElementById('dynamicPlot');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            
            window.currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: yAxis,
                        data: data,
                        borderColor: 'rgba(79, 70, 229, 1)',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: 'rgba(79, 70, 229, 1)',
                        pointBorderColor: 'rgba(255, 255, 255, 1)',
                        pointBorderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${yAxis} over ${xAxis} (${temporalType})${window.excludedPoints.size > 0 ? ` (${window.excludedPoints.size} points excluded)` : ''}${window.currentAxisRanges ? ` (${displayData.length} points in range)` : ''}`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    return displayData[dataIndex].originalXValue;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: `${xAxis} (${temporalType})`,
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: yAxis,
                                font: {
                                    weight: 'bold'
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const originalIndex = displayData[dataIndex].originalIndex;
                            
                            if (confirm(`Remove this data point from the chart?\n\nX: ${displayData[dataIndex].originalXValue}\nY: ${displayData[dataIndex].y}`)) {
                                removeDataPoint(originalIndex);
                            }
                        }
                    }
                }
            });
        }

        function generateTextLineChart(xAxis, yAxis) {
            // Generate line chart treating X-axis as text (categorical)
            const validData = csvData
                .map((row, index) => ({
                    x: row[xAxis],
                    y: parseFloat(row[yAxis]),
                    originalIndex: index
                }))
                .filter(point => point.x && point.x.toString().trim() !== '' && !isNaN(point.y))
                .filter(point => !window.excludedPoints.has(point.originalIndex));

            // Sort alphabetically (no chronological sorting)
            validData.sort((a, b) => a.x.toString().localeCompare(b.x.toString()));

            const labels = validData.map(point => point.x.toString());
            const data = validData.map(point => point.y);

            const canvas = document.getElementById('dynamicPlot');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            
            window.currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: yAxis,
                        data: data,
                        borderColor: 'rgba(220, 38, 38, 1)',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: 'rgba(220, 38, 38, 1)',
                        pointBorderColor: 'rgba(255, 255, 255, 1)',
                        pointBorderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${yAxis} vs ${xAxis} (Text Mode - Override Active)`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: `${xAxis} (Text)`,
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: yAxis,
                                font: {
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        }

        function showTemporalAggregationOptions(xAxis, yAxis, temporalType, validData) {
            // Show aggregation options for high-cardinality temporal data
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-temporal-suggestion">
                        <div class="preview-icon">📅</div>
                        <h4>High-Cardinality Temporal Data</h4>
                        <p>The <strong>${xAxis}</strong> column has <strong>${new Set(validData.map(p => p.x.getTime())).size}</strong> unique timestamps. 
                           Line charts work best with aggregated temporal data.</p>
                        <div class="error-message">
                            <strong>💡 Temporal Aggregation Options:</strong><br>
                            • <strong>Daily:</strong> Group by day, aggregate ${yAxis} values<br>
                            • <strong>Weekly:</strong> Group by week for longer time periods<br>
                            • <strong>Monthly:</strong> Group by month for yearly trends<br>
                            • <strong>Count:</strong> Show record counts per time period
                        </div>
                        <div class="temporal-suggestion-actions">
                            <button class="range-btn" onclick="aggregateTemporalData('${xAxis}', '${yAxis}', '${temporalType}', 'daily', 'mean')">
                                📅 Daily Aggregation (Mean)
                            </button>
                            <button class="range-btn secondary" onclick="aggregateTemporalData('${xAxis}', '${yAxis}', '${temporalType}', 'weekly', 'mean')">
                                📊 Weekly Aggregation (Mean)
                            </button>
                            <button class="range-btn secondary" onclick="aggregateTemporalData('${xAxis}', '${yAxis}', '${temporalType}', 'monthly', 'mean')">
                                📈 Monthly Aggregation (Mean)
                            </button>
                            <button class="range-btn secondary" onclick="customTemporalAggregation('${xAxis}', '${yAxis}', '${temporalType}')">
                                ⚙️ Custom Aggregation
                            </button>
                            <button class="range-btn" onclick="showAllTemporalData('${xAxis}', '${yAxis}', '${temporalType}')" style="background: #dc2626;">
                                👉 Show All Data Points
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        function aggregateTemporalData(xAxis, yAxis, temporalType, period, aggregationMethod) {
            // Parse and group temporal data by specified period
            const validData = csvData
                .map((row, index) => {
                    const xValue = parseTemporalValue(row[xAxis], temporalType);
                    const yValue = parseFloat(row[yAxis]);
                    return {
                        x: xValue,
                        y: yValue,
                        originalIndex: index,
                        originalXValue: row[xAxis]
                    };
                })
                .filter(point => point.x !== null && !isNaN(point.y))
                .filter(point => !window.excludedPoints.has(point.originalIndex));

            // Group by period
            const groupedData = {};
            validData.forEach(point => {
                let groupKey;
                switch (period) {
                    case 'daily':
                        groupKey = point.x.toISOString().split('T')[0]; // YYYY-MM-DD
                        break;
                    case 'weekly':
                        const weekStart = new Date(point.x);
                        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                        groupKey = weekStart.toISOString().split('T')[0];
                        break;
                    case 'monthly':
                        groupKey = `${point.x.getFullYear()}-${String(point.x.getMonth() + 1).padStart(2, '0')}`;
                        break;
                    default:
                        groupKey = point.x.toISOString().split('T')[0];
                }
                
                if (!groupedData[groupKey]) {
                    groupedData[groupKey] = [];
                }
                groupedData[groupKey].push(point.y);
            });

            // Calculate aggregated values and sort chronologically
            const aggregatedData = Object.keys(groupedData)
                .map(key => ({
                    x: new Date(key),
                    y: applyAggregation(groupedData[key], aggregationMethod),
                    label: key,
                    count: groupedData[key].length
                }))
                .sort((a, b) => a.x.getTime() - b.x.getTime());

            // Create the chart
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">📊</div>
                        <h4>Temporal Aggregation Applied</h4>
                        <p>Showing <strong>${getAggregationDisplayName(aggregationMethod)} ${yAxis}</strong> aggregated by <strong>${period}</strong></p>
                        <p><strong>Data points:</strong> ${aggregatedData.length} ${period} periods</p>
                        <div class="aggregation-method-selector">
                            <label for="temporalAggregationMethod">Aggregation Method:</label>
                            <select id="temporalAggregationMethod" onchange="updateTemporalAggregation('${xAxis}', '${yAxis}', '${temporalType}', '${period}')">
                                <option value="mean" ${aggregationMethod === 'mean' ? 'selected' : ''}>Mean (Average)</option>
                                <option value="median" ${aggregationMethod === 'median' ? 'selected' : ''}>Median</option>
                                <option value="sum" ${aggregationMethod === 'sum' ? 'selected' : ''}>Sum</option>
                                <option value="count" ${aggregationMethod === 'count' ? 'selected' : ''}>Count</option>
                                <option value="min" ${aggregationMethod === 'min' ? 'selected' : ''}>Minimum</option>
                                <option value="max" ${aggregationMethod === 'max' ? 'selected' : ''}>Maximum</option>
                            </select>
                        </div>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                generateAggregatedTemporalChart(aggregatedData, xAxis, yAxis, temporalType, period, aggregationMethod);
            }
        }

        function generateAggregatedTemporalChart(aggregatedData, xAxis, yAxis, temporalType, period, aggregationMethod) {
            const labels = aggregatedData.map(point => point.label);
            const data = aggregatedData.map(point => point.y);

            const canvas = document.getElementById('dynamicPlot');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            
            window.currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis}`,
                        data: data,
                        borderColor: 'rgba(79, 70, 229, 1)',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.1,
                        pointBackgroundColor: 'rgba(79, 70, 229, 1)',
                        pointBorderColor: 'rgba(255, 255, 255, 1)',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis} by ${period.charAt(0).toUpperCase() + period.slice(1)} (${xAxis})`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const dataIndex = context.dataIndex;
                                    return `Data points: ${aggregatedData[dataIndex].count}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: `${xAxis} (${period})`,
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            beginAtZero: aggregationMethod === 'count',
                            title: {
                                display: true,
                                text: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis}`,
                                font: {
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        }

        function customTemporalAggregation(xAxis, yAxis, temporalType) {
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">⚙️</div>
                        <h4>Custom Temporal Aggregation</h4>
                        <p>Configure how to aggregate <strong>${yAxis}</strong> over time periods</p>
                        
                        <div class="binning-controls">
                            <div class="binning-controls-grid">
                                <div class="binning-control-group">
                                    <label for="temporalPeriod">Time Period:</label>
                                    <select id="temporalPeriod">
                                        <option value="daily">Daily</option>
                                        <option value="weekly">Weekly</option>
                                        <option value="monthly">Monthly</option>
                                    </select>
                                </div>
                                <div class="binning-control-group">
                                    <label for="temporalAggregation">Aggregation:</label>
                                    <select id="temporalAggregation">
                                        <option value="mean">Mean (Average)</option>
                                        <option value="median">Median</option>
                                        <option value="sum">Sum</option>
                                        <option value="count">Count</option>
                                        <option value="min">Minimum</option>
                                        <option value="max">Maximum</option>
                                    </select>
                                </div>
                            </div>
                            <button class="range-btn" onclick="applyCustomTemporalAggregation('${xAxis}', '${yAxis}', '${temporalType}')">
                                📊 Apply Custom Aggregation
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        function applyCustomTemporalAggregation(xAxis, yAxis, temporalType) {
            const period = document.getElementById('temporalPeriod').value;
            const aggregationMethod = document.getElementById('temporalAggregation').value;
            
            aggregateTemporalData(xAxis, yAxis, temporalType, period, aggregationMethod);
        }

        function updateTemporalAggregation(xAxis, yAxis, temporalType, period) {
            const aggregationMethod = document.getElementById('temporalAggregationMethod').value;
            aggregateTemporalData(xAxis, yAxis, temporalType, period, aggregationMethod);
        }

        function showAllTemporalData(xAxis, yAxis, temporalType) {
            // Override aggregation and show all temporal data points
            window.ignoreTemporalAggregation = true;
            
            const plotPreview = document.querySelector('.plot-preview');
            if (plotPreview) {
                plotPreview.innerHTML = `
                    <div class="preview-ready">
                        <div class="preview-icon">🕒</div>
                        <h4>All Temporal Data Points</h4>
                        <p>Showing all individual data points for <strong>${xAxis}</strong> vs <strong>${yAxis}</strong></p>
                        <p>⚠️ <em>Note: Chart may be dense due to high cardinality</em></p>
                        <button class="range-btn secondary" onclick="restoreTemporalAggregation('${xAxis}', '${yAxis}', '${temporalType}')" style="margin-top: 1rem;">
                            📊 Re-enable Aggregation Options
                        </button>
                    </div>
                    <div class="plot-container">
                        <canvas id="dynamicPlot"></canvas>
                    </div>
                `;
                
                // Generate the full temporal line chart
                generateTemporalLineChart(xAxis, yAxis, temporalType);
            }
        }

        function restoreTemporalAggregation(xAxis, yAxis, temporalType) {
            // Remove aggregation override
            window.ignoreTemporalAggregation = false;
            
            // Show aggregation options again
            const validData = csvData
                .map((row, index) => {
                    const xValue = parseTemporalValue(row[xAxis], temporalType);
                    const yValue = parseFloat(row[yAxis]);
                    return {
                        x: xValue,
                        y: yValue,
                        originalIndex: index,
                        originalXValue: row[xAxis]
                    };
                })
                .filter(point => point.x !== null && !isNaN(point.y))
                .filter(point => !window.excludedPoints.has(point.originalIndex));

            showTemporalAggregationOptions(xAxis, yAxis, temporalType, validData);
        }

        function generateBinnedLineChart(xAxis, yAxis, binWidth, aggregationMethod, showSuccessMessage) {
            // Store current configuration
            window.currentPlotConfig = { xAxis, yAxis };
            window.forceBinnedLineChart = { xAxis, yAxis, binWidth, aggregationMethod };
            
            // Get data and calculate bins
            const xValues = csvData.map(row => parseFloat(row[xAxis])).filter(v => !isNaN(v));
            const yValues = csvData.map(row => parseFloat(row[yAxis])).filter(v => !isNaN(v));
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            
            // Create bins
            const bins = [];
            let binStart = Math.floor(xMin / binWidth) * binWidth;
            while (binStart <= xMax) {
                bins.push({
                    start: binStart,
                    end: binStart + binWidth,
                    label: `${binStart.toFixed(1)}-${(binStart + binWidth).toFixed(1)}`,
                    values: []
                });
                binStart += binWidth;
            }
            
            // Assign data points to bins
            csvData.forEach(row => {
                const xVal = parseFloat(row[xAxis]);
                const yVal = parseFloat(row[yAxis]);
                
                if (!isNaN(xVal) && !isNaN(yVal)) {
                    const binIndex = Math.floor((xVal - (Math.floor(xMin / binWidth) * binWidth)) / binWidth);
                    if (binIndex >= 0 && binIndex < bins.length) {
                        bins[binIndex].values.push(yVal);
                    }
                }
            });
            
            // Calculate aggregated values for each bin
            const binnedData = bins
                .filter(bin => bin.values.length > 0)
                .map(bin => ({
                    label: bin.label,
                    midpoint: bin.start + binWidth / 2,
                    value: applyAggregation(bin.values, aggregationMethod),
                    count: bin.values.length
                }));
            
            // Check if we have too few bins
            if (binnedData.length < 3 && showSuccessMessage) {
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    plotPreview.innerHTML = `
                        <div class="preview-error">
                            <div class="preview-icon">⚠️</div>
                            <h4>Too Few Bins Created</h4>
                            <p>The current bin width of <strong>${binWidth}</strong> creates only <strong>${binnedData.length} bins</strong>.</p>
                            <p>Consider using a <strong>Bar Chart</strong> instead or reducing the bin width.</p>
                            <div class="categorical-aggregation-actions" style="margin-top: 1rem;">
                                <button class="range-btn secondary" onclick="treatAsCategorical('${xAxis}', '${yAxis}')">
                                    📊 Use Bar Chart Instead
                                </button>
                                <button class="range-btn secondary" onclick="customBinAndAggregate('${xAxis}', '${yAxis}')">
                                    ⚙️ Adjust Bin Size
                                </button>
                            </div>
                        </div>
                    `;
                }
                return;
            }
            
            // Show success message if requested
            if (showSuccessMessage) {
                const plotPreview = document.querySelector('.plot-preview');
                if (plotPreview) {
                    const yAxisType = getEffectiveVariableType(yAxis);
                    const isPercentage = yAxisType === 'boolean' && aggregationMethod === 'mean';
                    
                    plotPreview.innerHTML = `
                        <div class="preview-ready">
                            <div class="preview-icon">📈</div>
                            <h4>Binned Line Chart Generated</h4>
                            <p>Showing <strong>${getAggregationDisplayName(aggregationMethod)} of ${yAxis}</strong> 
                               ${isPercentage ? '(as percentage)' : ''} for <strong>${binnedData.length} bins</strong> of ${xAxis}</p>
                            <p><em>Bin width: ${binWidth} | Total data points: ${csvData.length}</em></p>
                        </div>
                        <div class="plot-container">
                            <canvas id="dynamicPlot"></canvas>
                        </div>
                    `;
                }
            }
            
            // Create the chart
            const canvas = document.getElementById('dynamicPlot');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (window.currentChart) {
                window.currentChart.destroy();
            }
            
            const ctx = canvas.getContext('2d');
            const yAxisType = getEffectiveVariableType(yAxis);
            const isPercentage = yAxisType === 'boolean' && aggregationMethod === 'mean';
            
            // Convert to percentage if needed
            const chartData = isPercentage ? 
                binnedData.map(point => ({ ...point, value: point.value * 100 })) : 
                binnedData;
            
            window.currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.map(point => point.label),
                    datasets: [{
                        label: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis}${isPercentage ? ' (%)' : ''}`,
                        data: chartData.map(point => point.value),
                        borderColor: 'rgba(79, 70, 229, 1)',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        pointBackgroundColor: 'rgba(79, 70, 229, 1)',
                        pointBorderColor: 'rgba(255, 255, 255, 1)',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis} by ${xAxis} (Binned)`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const dataPoint = binnedData[context.dataIndex];
                                    return `Data points in bin: ${dataPoint.count}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: `${xAxis} (Binned, width: ${binWidth})`,
                                font: {
                                    weight: 'bold'
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: `${getAggregationDisplayName(aggregationMethod)} of ${yAxis}${isPercentage ? ' (%)' : ''}`,
                                font: {
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        }

        // Regression line functionality
        function calculateLinearRegression(xData, yData) {
            const n = xData.length;
            if (n === 0) return null;
            
            const sumX = xData.reduce((a, b) => a + b, 0);
            const sumY = yData.reduce((a, b) => a + b, 0);
            const sumXY = xData.reduce((sum, x, i) => sum + x * yData[i], 0);
            const sumXX = xData.reduce((sum, x) => sum + x * x, 0);
            const sumYY = yData.reduce((sum, y) => sum + y * y, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate R-squared
            const yMean = sumY / n;
            const totalSumSquares = yData.reduce((sum, y) => sum + (y - yMean) ** 2, 0);
            const residualSumSquares = yData.reduce((sum, y, i) => {
                const predicted = slope * xData[i] + intercept;
                return sum + (y - predicted) ** 2;
            }, 0);
            
            const rSquared = 1 - (residualSumSquares / totalSumSquares);
            
            return {
                slope: slope,
                intercept: intercept,
                rSquared: rSquared,
                equation: `y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}`
            };
        }

        function toggleRegressionLine() {
            const checkbox = document.getElementById('regressionToggle');
            const rSquaredDisplay = document.getElementById('rSquaredDisplay');
            
            if (checkbox.checked) {
                // Show R² display
                rSquaredDisplay.style.display = 'block';
                
                // Calculate and display regression
                updateRegressionAnalysis();
            } else {
                // Hide R² display
                rSquaredDisplay.style.display = 'none';
            }
            
            // Regenerate the plot
            if (window.currentPlotConfig) {
                generatePlot(
                    window.currentPlotConfig.plotType,
                    window.currentPlotConfig.xAxis,
                    window.currentPlotConfig.yAxis
                );
            }
        }

        function updateRegressionAnalysis() {
            if (!window.currentPlotConfig || window.currentPlotConfig.plotType !== 'scatter') {
                return;
            }
            
            const xAxis = window.currentPlotConfig.xAxis;
            const yAxis = window.currentPlotConfig.yAxis;
            
            // Get the current data being displayed
            const validData = csvData
                .map((row, index) => ({ 
                    x: parseFloat(row[xAxis]), 
                    y: parseFloat(row[yAxis]),
                    originalIndex: index 
                }))
                .filter(point => !isNaN(point.x) && !isNaN(point.y))
                .filter((point, index) => !window.excludedPoints.has(point.originalIndex));
            
            // Apply range filtering if active
            let displayData = validData;
            if (window.currentAxisRanges) {
                displayData = validData.filter(point => {
                    let includePoint = true;
                    if (window.currentAxisRanges.x.min !== null && point.x < window.currentAxisRanges.x.min) includePoint = false;
                    if (window.currentAxisRanges.x.max !== null && point.x > window.currentAxisRanges.x.max) includePoint = false;
                    if (window.currentAxisRanges.y.min !== null && point.y < window.currentAxisRanges.y.min) includePoint = false;
                    if (window.currentAxisRanges.y.max !== null && point.y > window.currentAxisRanges.y.max) includePoint = false;
                    return includePoint;
                });
            }
            
            const xData = displayData.map(point => point.x);
            const yData = displayData.map(point => point.y);
            
            const regression = calculateLinearRegression(xData, yData);
            
            if (regression) {
                document.getElementById('rSquaredValue').textContent = regression.rSquared.toFixed(4);
                document.getElementById('equationDisplay').textContent = regression.equation;
                
                // Store regression for use in chart
                window.currentRegression = regression;
            }
        }
    </script>
</body>
</html> 